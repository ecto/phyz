<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>phyz - Multi-physics differentiable simulation</title>
<meta name="description" content="A differentiable simulation engine for rigid bodies, particles, electromagnetic fields, molecular dynamics, and beyond. Pure Rust. GPU-accelerated.">
<style>
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Serif:ital,wght@0,400;0,500;1,400&display=swap');

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --bg: #faf9f7;
  --fg: #1a1a1a;
  --fg-muted: #555;
  --fg-faint: #999;
  --accent: #4a5fd7;
  --accent-hover: #3a4fc0;
  --code-bg: #f0efed;
  --border: #e0dfdd;
  --mono: 'IBM Plex Mono', 'Menlo', monospace;
  --serif: 'IBM Plex Serif', 'Georgia', serif;
}

html {
  font-size: 18px;
  -webkit-font-smoothing: antialiased;
}

body {
  background: var(--bg);
  color: var(--fg);
  font-family: var(--serif);
  line-height: 1.7;
}

::selection {
  background: var(--accent);
  color: white;
}

.container {
  max-width: 680px;
  margin: 0 auto;
  padding: 0 24px;
}

.container-wide {
  max-width: 100%;
  margin: 0 auto;
  padding: 0 40px;
}


/* ---- Hero ---- */

.hero {
  position: relative;
  padding: 120px 0 100px;
  overflow: hidden;
}

.hero canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.12;
  pointer-events: none;
}

.hero-content {
  position: relative;
  z-index: 1;
}

.wordmark {
  font-family: var(--mono);
  font-size: 4.5rem;
  font-weight: 600;
  letter-spacing: -0.03em;
  line-height: 1;
  margin-bottom: 20px;
}

.tagline {
  font-family: var(--serif);
  font-size: 1.35rem;
  color: var(--fg-muted);
  line-height: 1.5;
  margin-bottom: 8px;
}

.tagline-sub {
  font-family: var(--mono);
  font-size: 0.8rem;
  color: var(--fg-faint);
  letter-spacing: 0.04em;
  margin-bottom: 36px;
}

.install {
  display: inline-block;
  font-family: var(--mono);
  font-size: 0.85rem;
  background: var(--fg);
  color: var(--bg);
  padding: 10px 20px;
  border: none;
  cursor: pointer;
  transition: background 0.15s;
  letter-spacing: 0.01em;
}

.install:hover {
  background: var(--accent);
}

.install-copied {
  background: var(--accent) !important;
}


/* ---- Sections ---- */

section {
  padding: 80px 0;
}


/* ---- Pitch ---- */

.pitch p {
  font-size: 1.05rem;
  margin-bottom: 1.5em;
  color: var(--fg);
}

.pitch p:last-child {
  margin-bottom: 0;
}


/* ---- Code ---- */

.section-label {
  font-family: var(--mono);
  font-size: 0.8rem;
  font-weight: 500;
  color: var(--fg-faint);
  letter-spacing: 0.05em;
  text-transform: uppercase;
  margin-bottom: 20px;
}

pre {
  font-family: var(--mono);
  font-size: 0.78rem;
  line-height: 1.65;
  background: var(--code-bg);
  padding: 24px 28px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

pre .kw { color: #7c4dff; }
pre .fn { color: #1a1a1a; font-weight: 500; }
pre .str { color: #2e7d32; }
pre .num { color: #c62828; }
pre .cm { color: #999; font-style: italic; }
pre .ty { color: #4a5fd7; }
pre .mac { color: #6d4c41; }


/* ---- Crate Examples ---- */

.crate-tag {
  font-family: var(--mono);
  font-size: 0.7rem;
  font-weight: 500;
  color: var(--fg-faint);
  text-decoration: none;
  display: block;
  margin-bottom: 2px;
  transition: color 0.15s;
}

.crate-tag:hover {
  color: var(--accent);
}

.examples-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 24px;
}

.example-card {
  display: flex;
  flex-direction: column;
}

.example-card canvas {
  width: 100%;
  aspect-ratio: 4 / 3;
  background: var(--code-bg);
  display: block;
  cursor: grab;
  border-radius: 4px;
}

.example-card canvas:active {
  cursor: grabbing;
}

.example-meta {
  padding-top: 12px;
}

.example-meta .label {
  font-family: var(--mono);
  font-size: 0.78rem;
  font-weight: 500;
  display: block;
  margin-bottom: 4px;
}

.example-meta .desc {
  font-family: var(--serif);
  font-size: 0.82rem;
  color: var(--fg-muted);
  line-height: 1.5;
}

.example-meta .stat {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--fg-faint);
  margin-top: 6px;
  display: block;
}

a.label {
  color: var(--fg);
  text-decoration: none;
  border-bottom: 1px solid var(--border);
  transition: color 0.15s, border-color 0.15s;
}

a.label:hover {
  color: var(--accent);
  border-color: var(--accent);
}

.crate-also {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--fg-faint);
  margin-top: 12px;
  display: block;
}

.crate-also a {
  color: var(--fg-muted);
  text-decoration: none;
  border-bottom: 1px solid var(--border);
  transition: color 0.15s, border-color 0.15s;
}

.crate-also a:hover {
  color: var(--accent);
  border-color: var(--accent);
}



/* ---- Footer ---- */

footer {
  padding: 60px 0 80px;
}

footer .footer-inner {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  flex-wrap: wrap;
  gap: 16px;
}

footer a {
  font-family: var(--mono);
  font-size: 0.8rem;
  color: var(--fg-muted);
  text-decoration: none;
  transition: color 0.15s;
}

footer a:hover {
  color: var(--accent);
}

footer .license {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--fg-faint);
}


/* ---- Responsive ---- */

@media (max-width: 1100px) {
  .examples-grid { grid-template-columns: repeat(2, 1fr); }
}

@media (max-width: 700px) {
  .examples-grid { grid-template-columns: 1fr; }
  .container-wide { padding: 0 16px; }
}

@media (max-width: 600px) {
  .wordmark { font-size: 3rem; }
  .tagline { font-size: 1.1rem; }
  .hero { padding: 80px 0 60px; }
  section { padding: 56px 0; }

  pre { font-size: 0.72rem; padding: 18px 16px; }
}
</style>
</head>
<body>

<!-- Hero -->
<div class="hero">
  <canvas id="sim"></canvas>
  <div class="container hero-content">
    <div class="wordmark">phyz</div>
    <div class="tagline">Multi-physics differentiable simulation.</div>
    <div class="tagline-sub">Pure Rust. GPU-accelerated. Hackable.</div>
    <button class="install" onclick="copyInstall(this)" title="Copy to clipboard">cargo add phyz</button>
  </div>
</div>

<!-- Pitch -->
<section class="pitch">
  <div class="container">
    <p>
      phyz is a differentiable simulation engine for articulated rigid bodies,
      particles, electromagnetic fields, molecular dynamics, and beyond.
      Every algorithm computes gradients for optimization,
      control, and learning.
    </p>
    <p>
      Built on Featherstone's spatial algebra, phyz runs O(n) forward dynamics
      with analytical Jacobians. Plug in semi-implicit Euler, RK4, or your own
      solver. Load MuJoCo MJCF models. Batch thousands of environments on GPU.
    </p>
    <p>
      phyz is early, ambitious, and open source.
    </p>
  </div>
</section>

<!-- Code -->
<section class="code-section">
  <div class="container">
    <h2 class="section-label">Code</h2>
<pre><span class="kw">use</span> phyz::{<span class="ty">ModelBuilder</span>, <span class="ty">Simulator</span>, <span class="ty">Vec3</span>};
<span class="kw">use</span> phyz_diff::<span class="fn">analytical_step_jacobians</span>;

<span class="cm">// Double pendulum: two revolute joints</span>
<span class="kw">let</span> model = <span class="ty">ModelBuilder</span>::new()
    .add_revolute_body(<span class="str">"upper"</span>, -<span class="num">1</span>, <span class="num">1.0</span>, <span class="ty">Vec3</span>::new(<span class="num">0.</span>, <span class="num">0.</span>, -<span class="num">1.</span>))
    .add_revolute_body(<span class="str">"lower"</span>,  <span class="num">0</span>, <span class="num">0.8</span>, <span class="ty">Vec3</span>::new(<span class="num">0.</span>, <span class="num">0.</span>, -<span class="num">1.</span>))
    .build();

<span class="kw">let mut</span> state = model.default_state();
state.q  = <span class="mac">vec!</span>[<span class="num">0.5</span>, -<span class="num">0.3</span>];  <span class="cm">// joint angles</span>
state.qd = <span class="mac">vec!</span>[<span class="num">0.0</span>,  <span class="num">0.0</span>];  <span class="cm">// velocities</span>

<span class="cm">// Simulate with analytical Jacobians at every step</span>
<span class="kw">let</span> sim = <span class="ty">Simulator</span>::rk4();
<span class="kw">let</span> dt = <span class="num">0.002</span>;

<span class="kw">for</span> _ <span class="kw">in</span> <span class="num">0</span>..<span class="num">500</span> {
    <span class="kw">let</span> jac = <span class="fn">analytical_step_jacobians</span>(&amp;model, &amp;state, dt);
    sim.step(&amp;model, &amp;<span class="kw">mut</span> state, dt);

    <span class="cm">// jac.dq_dq0: ∂(next state) / ∂(current state)</span>
    <span class="cm">// jac.dq_dtau: ∂(next state) / ∂(applied torques)</span>
    <span class="cm">// → chain rule through the trajectory for end-to-end gradients</span>
}

<span class="kw">let</span> tip = state.body_position(<span class="num">1</span>);
<span class="mac">println!</span>(<span class="str">"tip = ({:.3}, {:.3})"</span>, tip.x, tip.y);
<span class="mac">println!</span>(<span class="str">"sensitivity ‖∂q'/∂q₀‖ = {:.2e}"</span>, jac.dq_dq0.norm());</pre>
  </div>
</section>

<!-- Crate Examples -->
<section class="examples">
  <div class="container-wide">
    <div class="examples-grid">

      <div class="example-card">
        <canvas id="ex-double"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-rigid">phyz-rigid</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/double_pendulum.rs">double_pendulum</a>
          <span class="desc">Chaotic two-link chain with joint dissipation.</span>
          <span class="stat" id="stat-double">loading wasm...</span>
          <span class="crate-also">Also: pendulum, chain</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-cascade"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-contact">phyz-contact</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/ball_drop.rs">sphere_cascade</a>
          <span class="desc">20 spheres pile up. GJK/EPA + penalty contacts.</span>
          <span class="stat" id="stat-cascade">loading wasm...</span>
          <span class="crate-also">Also: bouncing_spheres, newtons_cradle</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-ensemble"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-gpu">phyz-gpu</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/ensemble_pendulum.rs">ensemble_divergence</a>
          <span class="desc">100 double pendulums. Lyapunov divergence in real time.</span>
          <span class="stat" id="stat-ensemble">loading wasm...</span>
          <span class="crate-also">Also: wave_field, policy_search</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-granular"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-particle">phyz-particle</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/granular_column.rs">granular_column</a>
          <span class="desc">280 particles. Drucker-Prager yield via MPM.</span>
          <span class="stat" id="stat-granular">loading wasm...</span>
          <span class="crate-also">Also: fluid_dam, elastic_blob, hourglass</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-hourglass"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-particle">phyz-particle</a>
          <a class="label">hourglass</a>
          <span class="desc">Sand flowing through a narrow neck. DEM with funnel boundaries.</span>
          <span class="stat" id="stat-hourglass">loading wasm...</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-tendon"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-world">phyz-world</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/tendon_demo.rs">tendon_demo</a>
          <span class="desc">4-link chain with sinusoidal tendon actuation.</span>
          <span class="stat" id="stat-tendon">loading wasm...</span>
          <span class="crate-also">Also: random_chain, phase_portrait, gripper</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-gripper"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-world">phyz-world</a>
          <a class="label">tendon_gripper</a>
          <span class="desc">2-finger gripper grasping a ball. Sinusoidal open/close cycle.</span>
          <span class="stat" id="stat-gripper">loading wasm...</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-slit"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-em">phyz-em</a>
          <a class="label" href="https://github.com/ecto/phyz/tree/main/crates/phyz-em">double_slit</a>
          <span class="desc">FDTD plane wave. Interference fringes in real time.</span>
          <span class="stat" id="stat-slit">loading wasm...</span>
          <span class="crate-also">Also: dipole_radiation, waveguide</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-polymer"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-md">phyz-md</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/crates/phyz-md/examples/argon_fluid.rs">polymer_chain</a>
          <span class="desc">40-bead LJ chain. Coil-stretch dynamics.</span>
          <span class="stat" id="stat-polymer">loading wasm...</span>
          <span class="crate-also">Also: argon_gas, crystal_lattice, cooling_gas</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-cooling"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-md">phyz-md</a>
          <a class="label">cooling_gas</a>
          <span class="desc">120 LJ particles cooling from gas to crystal. Color by kinetic energy.</span>
          <span class="stat" id="stat-cooling">loading wasm...</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-plaq"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-qft">phyz-qft</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/crates/phyz-qft/examples/phase_transition.rs">u1_plaquette</a>
          <span class="desc">16x16 U(1) lattice. Metropolis updates at beta=2.0.</span>
          <span class="stat" id="stat-plaq">loading wasm...</span>
          <span class="crate-also">Also: wilson_loops, phase_transition</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-spiral"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-coupling">phyz-coupling</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/crates/phyz-coupling/examples/lorentz_pendulum.rs">lorentz_spiral</a>
          <span class="desc">Charged particle spiraling in uniform B field.</span>
          <span class="stat" id="stat-spiral">loading wasm...</span>
          <span class="crate-also">Also: crossed_fields, magnetic_mirror</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-solar"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-gravity">phyz-gravity</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/mercury_precession.rs">solar_system</a>
          <span class="desc">5 planets. Kepler orbits with post-Newtonian corrections.</span>
          <span class="stat" id="stat-solar">loading wasm...</span>
          <span class="crate-also">Also: binary_orbit, precession, galaxy_collision</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-sandbox" style="cursor: crosshair"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-gravity">phyz-gravity</a>
          <a class="label">gravity_sandbox</a>
          <span class="desc">Click to place masses. Watch orbits form. Bodies merge on collision.</span>
          <span class="stat" id="stat-sandbox">click to add bodies</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-galaxy"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-gravity">phyz-gravity</a>
          <a class="label">galaxy_collision</a>
          <span class="desc">Two disk galaxies merging. 400 bodies with tidal tails.</span>
          <span class="stat" id="stat-galaxy">loading wasm...</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-adaptdt"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-guardian">phyz-guardian</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/crates/phyz-guardian/examples/adaptive_pendulum.rs">adaptive_dt</a>
          <span class="desc">Fixed vs adaptive timestep. Watch energy drift.</span>
          <span class="stat" id="stat-adaptdt">loading wasm...</span>
          <span class="crate-also">Also: energy_monitor, correction_demo</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-vortex"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-lbm">phyz-lbm</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/lbm_cavity.rs">vortex_street</a>
          <span class="desc">D2Q9 flow around obstacle. Von Karman vortex street.</span>
          <span class="stat" id="stat-vortex">loading wasm...</span>
          <span class="crate-also">Also: cavity_flow, channel_flow</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-svgd"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-prob">phyz-prob</a>
          <a class="label" href="https://github.com/ecto/phyz/tree/main/crates/phyz-prob">svgd_particles</a>
          <span class="desc">SVGD converging to a Gaussian mixture target.</span>
          <span class="stat" id="stat-svgd">loading wasm...</span>
          <span class="crate-also">Also: uncertainty_cone, monte_carlo</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-gradtarget"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-diff">phyz-diff</a>
          <a class="label" href="https://github.com/ecto/phyz/tree/main/crates/phyz-diff">gradient_target</a>
          <span class="desc">Gradient descent optimizing angle to hit a target.</span>
          <span class="stat" id="stat-gradtarget">loading wasm...</span>
          <span class="crate-also">Also: jacobian_heatmap, sensitivity</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-ant"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-mjcf">phyz-mjcf</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/ant.rs">load_ant</a>
          <span class="desc">Ant kinematic tree: 4 legs with hip and shin joints.</span>
          <span class="stat" id="stat-ant">loading wasm...</span>
          <span class="crate-also">Also: load_cartpole, model_editor</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-ragdoll"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-collision">phyz-collision</a>
          <a class="label">ragdoll_tumble</a>
          <span class="desc">12-joint ragdoll tumbling down stairs. Verlet + distance constraints.</span>
          <span class="stat" id="stat-ragdoll">loading wasm...</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-rube"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-coupling">phyz-coupling</a>
          <a class="label">rube_goldberg</a>
          <span class="desc">Ball → dominoes → pendulum → bucket. Multi-physics chain reaction.</span>
          <span class="stat" id="stat-rube">loading wasm...</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-lossland"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-real2sim">phyz-real2sim</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/examples/real2sim_pendulum.rs">loss_landscape</a>
          <span class="desc">2D loss contour with gradient descent path overlay.</span>
          <span class="stat" id="stat-lossland">loading wasm...</span>
          <span class="crate-also">Also: param_fit, adam_vs_gd</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-curvslice"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-regge">phyz-regge</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/crates/phyz-regge/examples/rn_symmetry_search.rs">curvature_slice</a>
          <span class="desc">Reissner-Nordstrom edge lengths as color heatmap.</span>
          <span class="stat" id="stat-curvslice">loading wasm...</span>
          <span class="crate-also">Also: symmetry_bars, action_landscape</span>
        </div>
      </div>

      <div class="example-card">
        <canvas id="ex-kernelir"></canvas>
        <div class="example-meta">
          <a class="crate-tag" href="https://github.com/ecto/phyz/tree/main/crates/phyz-compile">phyz-compile</a>
          <a class="label" href="https://github.com/ecto/phyz/blob/main/crates/phyz-compile/examples/fusion.rs">kernel_ir</a>
          <span class="desc">Physics kernel IR DAG: fields, stencils, binary ops.</span>
          <span class="stat" id="stat-kernelir">loading wasm...</span>
          <span class="crate-also">Also: wgsl_output, fusion_viz</span>
        </div>
      </div>

    </div>
  </div>
</section>

<!-- Footer -->
<footer>
  <div class="container footer-inner">
    <a href="https://github.com/ecto/phyz">GitHub</a>
    <a href="https://docs.rs/phyz">docs.rs</a>
    <span class="license">MIT</span>
  </div>
</footer>

<script>
function copyInstall(el) {
  navigator.clipboard.writeText('cargo add phyz');
  el.textContent = 'copied';
  el.classList.add('install-copied');
  setTimeout(() => {
    el.textContent = 'cargo add phyz';
    el.classList.remove('install-copied');
  }, 1500);
}
</script>

<!-- Hero background: lightweight 2D trace (no WASM needed) -->
<script>
(function() {
  const canvas = document.getElementById('sim');
  const ctx = canvas.getContext('2d');
  let w, h, dpr;
  function resize() {
    dpr = window.devicePixelRatio || 1;
    const rect = canvas.parentElement.getBoundingClientRect();
    w = rect.width; h = rect.height;
    canvas.width = w * dpr; canvas.height = h * dpr;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);
  const g = 9.81, l1 = 0.35, l2 = 0.30, m1 = 1.0, m2 = 1.0;
  let th1 = Math.PI*0.75, th2 = Math.PI*0.5, w1 = 0, w2 = 0;
  const dt = 0.004, spf = 4, trail = [], maxTrail = 600;
  function derivs(t1,t2,o1,o2) {
    const s=Math.sin(t1-t2),c=Math.cos(t1-t2),den=2*m1+m2-m2*Math.cos(2*(t1-t2));
    return [o1,o2,
      (-g*(2*m1+m2)*Math.sin(t1)-m2*g*Math.sin(t1-2*t2)-2*s*m2*(o2*o2*l2+o1*o1*l1*c))/(l1*den),
      (2*s*(o1*o1*l1*(m1+m2)+g*(m1+m2)*Math.cos(t1)+o2*o2*l2*m2*c))/(l2*den)];
  }
  function step() {
    for (let i=0;i<spf;i++) {
      const k1=derivs(th1,th2,w1,w2);
      const k2=derivs(th1+dt/2*k1[0],th2+dt/2*k1[1],w1+dt/2*k1[2],w2+dt/2*k1[3]);
      const k3=derivs(th1+dt/2*k2[0],th2+dt/2*k2[1],w1+dt/2*k2[2],w2+dt/2*k2[3]);
      const k4=derivs(th1+dt*k3[0],th2+dt*k3[1],w1+dt*k3[2],w2+dt*k3[3]);
      th1+=dt/6*(k1[0]+2*k2[0]+2*k3[0]+k4[0]);
      th2+=dt/6*(k1[1]+2*k2[1]+2*k3[1]+k4[1]);
      w1+=dt/6*(k1[2]+2*k2[2]+2*k3[2]+k4[2]);
      w2+=dt/6*(k1[3]+2*k2[3]+2*k3[3]+k4[3]);
    }
    const sc=Math.min(w,h)*0.9,ox=w*0.7,oy=h*0.35;
    trail.push([ox+l1*sc*Math.sin(th1)+l2*sc*Math.sin(th2),oy+l1*sc*Math.cos(th1)+l2*sc*Math.cos(th2)]);
    if(trail.length>maxTrail) trail.shift();
  }
  function draw() {
    ctx.clearRect(0,0,w,h);
    for(let i=1;i<trail.length;i++){
      ctx.beginPath();ctx.moveTo(trail[i-1][0],trail[i-1][1]);ctx.lineTo(trail[i][0],trail[i][1]);
      ctx.strokeStyle=`rgba(74,95,215,${i/trail.length*0.7})`;ctx.lineWidth=0.8;ctx.stroke();
    }
    const sc=Math.min(w,h)*0.9,ox=w*0.7,oy=h*0.35;
    const x1=ox+l1*sc*Math.sin(th1),y1=oy+l1*sc*Math.cos(th1);
    const x2=x1+l2*sc*Math.sin(th2),y2=y1+l2*sc*Math.cos(th2);
    ctx.beginPath();ctx.moveTo(ox,oy);ctx.lineTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle='rgba(26,26,26,0.25)';ctx.lineWidth=1;ctx.stroke();
    ctx.fillStyle='rgba(26,26,26,0.3)';
    [[ox,oy],[x1,y1],[x2,y2]].forEach(([x,y])=>{ctx.beginPath();ctx.arc(x,y,2,0,Math.PI*2);ctx.fill();});
  }
  (function loop(){step();draw();requestAnimationFrame(loop);})();
})();
</script>

<!-- Three.js examples powered by phyz WASM -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import init, { WasmSim, WasmParticleSim, WasmCradleSim, WasmWaveFieldSim, WasmEnsembleSim, WasmPolicyGridSim, WasmMpmSim, WasmWorldSim, WasmEmSim, WasmMdSim, WasmQftSim, WasmLorentzSim, WasmGravitySim, WasmGuardianSim, WasmLbmSim, WasmProbSim, WasmDiffGradientSim, WasmDiffJacobianSim, WasmDiffSensitivitySim, WasmMjcfAntSim, WasmMjcfCartpoleSim, WasmMjcfEditorSim, WasmReal2SimFitSim, WasmReal2SimLandscapeSim, WasmReal2SimAdamVsGdSim, WasmReggeCurvatureSim, WasmReggeSymmetrySim, WasmReggeActionSim, WasmCompileIrSim, WasmCompileWgslSim, WasmCompileFusionSim, WasmHourglassSim, WasmRagdollSim, WasmGravitySandboxSim, WasmGripperSim, WasmRubeGoldbergSim } from './pkg/phyz_wasm.js';

// ---- Shared ----
const BG = 0xfaf9f7;
const ACCENT = 0x4a5fd7;
const DARK = 0x1a1a1a;
const MUTED = 0x888888;

// Single shared WebGL renderer. Renders each scene to an offscreen canvas,
// then blits to the visible canvas via 2D drawImage. One WebGL context total.
const sharedCanvas = document.createElement('canvas');
const sharedRenderer = new THREE.WebGLRenderer({ canvas: sharedCanvas, antialias: true });
sharedRenderer.setPixelRatio(1); // we handle dpr manually via setSize
sharedRenderer.setClearColor(BG);

// All active visualizations: canvasId -> { scene, camera, controls, canvas, ctx2d, update, visible }
const vizEntries = new Map();
const visibleSet = new Set();

// IntersectionObserver tracks which canvases are on-screen
const vizObserver = new IntersectionObserver((entries) => {
  for (const e of entries) {
    if (e.isIntersecting) visibleSet.add(e.target.id);
    else visibleSet.delete(e.target.id);
  }
}, { rootMargin: '100px 0px' });

function registerViz(canvasId, setupFn) {
  vizEntries.set(canvasId, { setup: setupFn, initialized: false });
}

function ensureInitialized(canvasId) {
  const entry = vizEntries.get(canvasId);
  if (!entry || entry.initialized) return;
  entry.initialized = true;
  const result = entry.setup(); // returns { scene, camera, controls, canvas, update }
  Object.assign(entry, result);
  // Get a 2D context for blitting
  entry.ctx2d = entry.canvas.getContext('2d');
}

// Central render loop: update + render only visible scenes
function globalLoop() {
  requestAnimationFrame(globalLoop);
  for (const canvasId of visibleSet) {
    const entry = vizEntries.get(canvasId);
    if (!entry) continue;
    ensureInitialized(canvasId);
    if (!entry.scene) continue;

    // Run sim update. If update returns a number, it's a motion metric for stall detection.
    const motion = entry.update();
    if (typeof motion === 'number') {
      if (motion < 0.0005) {
        entry._stallFrames = (entry._stallFrames || 0) + 1;
        if (entry._stallFrames > 180) { // ~3 seconds at 60fps
          entry.initialized = false;
          entry._stallFrames = 0;
          ensureInitialized(canvasId);
          if (!entry.scene) continue;
        }
      } else {
        entry._stallFrames = 0;
      }
    }

    // Size shared renderer to match this canvas
    const rect = entry.canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    if (w === 0 || h === 0) continue;
    const dpr = window.devicePixelRatio || 1;
    const pw = Math.floor(w * dpr), ph = Math.floor(h * dpr);
    sharedRenderer.setSize(pw, ph, false);
    entry.camera.aspect = w / h;
    entry.camera.updateProjectionMatrix();
    entry.controls.update();

    // Render to shared canvas
    sharedRenderer.render(entry.scene, entry.camera);

    // Blit to visible canvas (only resize if needed to avoid clearing)
    if (entry.canvas.width !== pw || entry.canvas.height !== ph) {
      entry.canvas.width = pw;
      entry.canvas.height = ph;
    }
    entry.ctx2d.drawImage(sharedCanvas, 0, 0);
  }
}
requestAnimationFrame(globalLoop);

// createScene: sets up scene/camera/controls but NO renderer (shared renderer is used)
function createScene(canvasId) {
  const canvas = document.getElementById(canvasId);
  const scene = new THREE.Scene();
  const rect = canvas.getBoundingClientRect();
  const camera = new THREE.PerspectiveCamera(35, rect.width / rect.height, 0.1, 100);
  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;
  controls.enableZoom = false;
  controls.enablePan = false;
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(3, 5, 4);
  scene.add(dir);
  return { scene, camera, controls, canvas };
}

function makeCyl(radius, length, color) {
  return new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, length, 12),
    new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.1 })
  );
}

function makeSphere(radius, color, opts) {
  const mat = { color, roughness: 0.5, metalness: 0.15, ...(opts || {}) };
  return new THREE.Mesh(
    new THREE.SphereGeometry(radius, 16, 16),
    new THREE.MeshStandardMaterial(mat)
  );
}

function makeTrail(maxPts, color, opacity) {
  const pts = [];
  for (let i = 0; i < maxPts; i++) pts.push(new THREE.Vector3());
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
  return { line: new THREE.Line(geo, mat), geo, maxPts };
}

function pushTrail(trail, x, y, z) {
  const pos = trail.geo.attributes.position.array;
  for (let i = 0; i < (trail.maxPts - 1) * 3; i++) pos[i] = pos[i + 3];
  pos[(trail.maxPts - 1) * 3]     = x;
  pos[(trail.maxPts - 1) * 3 + 1] = y;
  pos[(trail.maxPts - 1) * 3 + 2] = z;
  trail.geo.attributes.position.needsUpdate = true;
}

function makeGround(width, depth, y) {
  const geo = new THREE.BoxGeometry(width, 0.02, depth);
  const mat = new THREE.MeshStandardMaterial({ color: 0xd0cfcd, roughness: 0.9, metalness: 0.0 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.y = y - 0.01;
  return mesh;
}

// ---- Init WASM then start examples ----
await init();

const E0 = {};


// =========================================
// phyz-rigid: Single Pendulum
// =========================================
registerViz('ex-pendulum', () => {
  const sim = WasmSim.pendulum();
  E0.pendulum = sim.total_energy();
  const { scene, camera, controls, canvas } = createScene('ex-pendulum');
  camera.position.set(0, 0, 4.5);
  controls.target.set(0, -0.5, 0);

  const L = 1.5;
  scene.add(makeSphere(0.04, DARK));
  const rod = makeCyl(0.02, L, MUTED); scene.add(rod);
  const bob = makeSphere(0.08, ACCENT); scene.add(bob);
  const trail = makeTrail(300, ACCENT, 0.3); scene.add(trail.line);

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const th = sim.joint_angles()[0];
    const bx = L * Math.sin(th), by = -L * Math.cos(th);
    bob.position.set(bx, by, 0);
    rod.position.set(bx / 2, by / 2, 0);
    rod.rotation.z = th;
    pushTrail(trail, bx, by, 0);
    const E = sim.total_energy();
    const pct = (E / E0.pendulum * 100).toFixed(0);
    const el = document.getElementById('stat-pendulum');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  E=${E.toFixed(2)}J (${pct}%)`;
    const _cur = sim.joint_angles()[0];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-rigid: Double Pendulum
// =========================================
registerViz('ex-double', () => {
  const sim = WasmSim.double_pendulum();
  E0.double = sim.total_energy();
  const { scene, camera, controls, canvas } = createScene('ex-double');
  camera.position.set(0, -0.8, 7);
  controls.target.set(0, -0.8, 0);

  const L1 = 1.0, L2 = 1.0;
  scene.add(makeSphere(0.04, DARK));
  const rod1 = makeCyl(0.02, L1, MUTED);
  const rod2 = makeCyl(0.02, L2, MUTED);
  const joint = makeSphere(0.04, DARK);
  const bob = makeSphere(0.07, ACCENT);
  scene.add(rod1); scene.add(rod2); scene.add(joint); scene.add(bob);
  const trail = makeTrail(500, ACCENT, 0.25); scene.add(trail.line);

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const epos = sim.body_endpoint_positions();
    const e0x = epos[0], e0y = epos[1], e1x = epos[3], e1y = epos[4];
    joint.position.set(e0x, e0y, 0);
    bob.position.set(e1x, e1y, 0);
    rod1.position.set(e0x / 2, e0y / 2, 0);
    rod1.rotation.z = Math.atan2(e0x, -e0y);
    rod1.scale.y = Math.sqrt(e0x * e0x + e0y * e0y) / L1;
    const dx = e1x - e0x, dy = e1y - e0y;
    rod2.position.set(e0x + dx / 2, e0y + dy / 2, 0);
    rod2.rotation.z = Math.atan2(dx, -dy);
    rod2.scale.y = Math.sqrt(dx * dx + dy * dy) / L2;
    pushTrail(trail, e1x, e1y, 0);
    const E = sim.total_energy();
    const pct = (E / E0.double * 100).toFixed(0);
    const el = document.getElementById('stat-double');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  E=${E.toFixed(2)}J (${pct}%)`;
    const _cur = sim.body_endpoint_positions()[3];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-rigid: 8-link Chain
// =========================================
registerViz('ex-chain', () => {
  const N = 8, L = 0.6;
  const sim = WasmSim.chain(N);
  const { scene, camera, controls, canvas } = createScene('ex-chain');
  camera.position.set(0, -2, 7);
  controls.target.set(0, -2.5, 0);
  scene.add(makeSphere(0.04, DARK));
  const rods = [], joints = [];
  for (let i = 0; i < N; i++) {
    const rod = makeCyl(0.015, L, MUTED); scene.add(rod); rods.push(rod);
    const j = makeSphere(0.03, i === N - 1 ? ACCENT : DARK); scene.add(j); joints.push(j);
  }
  const trail = makeTrail(400, ACCENT, 0.2); scene.add(trail.line);
  E0.chain = sim.total_energy();

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const epos = sim.body_endpoint_positions();
    let prevX = 0, prevY = 0;
    for (let i = 0; i < N; i++) {
      const ex = epos[i * 3], ey = epos[i * 3 + 1];
      joints[i].position.set(ex, ey, 0);
      const dx = ex - prevX, dy = ey - prevY;
      const len = Math.sqrt(dx * dx + dy * dy);
      rods[i].position.set((prevX + ex) / 2, (prevY + ey) / 2, 0);
      rods[i].rotation.z = Math.atan2(dx, -dy);
      rods[i].scale.y = len / L;
      prevX = ex; prevY = ey;
    }
    pushTrail(trail, prevX, prevY, 0);
    const E = sim.total_energy();
    const pct = (E / E0.chain * 100).toFixed(0);
    const el = document.getElementById('stat-chain');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  E=${E.toFixed(2)}J (${pct}%)`;
    const _cur = prevX;
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-contact: Bouncing Spheres
// =========================================
registerViz('ex-bouncing', () => {
  const sim = WasmParticleSim.bouncing_spheres();
  const { scene, camera, controls, canvas } = createScene('ex-bouncing');
  camera.position.set(0, 1.2, 4.5);
  controls.target.set(0, 0.8, 0);
  scene.add(makeGround(3, 1, 0));
  const R = sim.radii()[0];
  const colors = [0xe74c3c, ACCENT, 0x888888];
  const spheres = [], trails = [];
  for (let i = 0; i < 3; i++) {
    const s = makeSphere(R, colors[i]); scene.add(s); spheres.push(s);
    const t = makeTrail(150, colors[i], 0.2); scene.add(t.line); trails.push(t);
  }

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(32);
    const pos = sim.positions();
    for (let i = 0; i < 3; i++) {
      const x = pos[i*3], y = pos[i*3+1], z = pos[i*3+2];
      spheres[i].position.set(x, y, z);
      pushTrail(trails[i], x, y, z);
    }
    const el = document.getElementById('stat-bouncing');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  elastic / medium / dead`;
    const _cur = sim.positions()[1];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-contact: Sphere Cascade
// =========================================
registerViz('ex-cascade', () => {
  const sim = WasmParticleSim.sphere_cascade();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-cascade');
  camera.position.set(0, 1.0, 4.5);
  controls.target.set(0, 0.5, 0);
  scene.add(makeGround(2, 1, 0));
  const R = sim.radii()[0];
  const spheres = [];
  for (let i = 0; i < N; i++) {
    const hue = 0.6 + i * 0.012;
    const color = new THREE.Color().setHSL(hue % 1, 0.55, 0.55);
    const s = makeSphere(R, color); scene.add(s); spheres.push(s);
  }

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(32);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) spheres[i].position.set(pos[i*3], pos[i*3+1], pos[i*3+2]);
    const el = document.getElementById('stat-cascade');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} bodies  GJK/penalty`;
    const _cur = sim.positions()[1];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-contact: Newton's Cradle
// =========================================
registerViz('ex-cradle', () => {
  const sim = WasmCradleSim.new();
  const N = sim.num_bobs(), R = sim.bob_radius();
  const { scene, camera, controls, canvas } = createScene('ex-cradle');
  camera.position.set(0, -0.3, 4);
  controls.target.set(0, -0.7, 0);
  const pivots = sim.pivot_positions();
  const barLen = pivots[(N-1)*3] - pivots[0] + 0.3;
  const bar = makeCyl(0.015, barLen, DARK);
  bar.rotation.z = Math.PI / 2;
  scene.add(bar);
  const strings = [], bobs = [];
  for (let i = 0; i < N; i++) {
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,-1,0)]);
    const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.5 }));
    scene.add(line); strings.push(line);
    const bob = makeSphere(R, 0x999999, { roughness: 0.2, metalness: 0.8 });
    scene.add(bob); bobs.push(bob);
  }

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(32);
    const bobPos = sim.bob_positions(), pivotPos = sim.pivot_positions();
    for (let i = 0; i < N; i++) {
      const px = pivotPos[i*3], py = pivotPos[i*3+1], bx = bobPos[i*3], by = bobPos[i*3+1];
      bobs[i].position.set(bx, by, 0);
      const arr = strings[i].geometry.attributes.position.array;
      arr[0]=px; arr[1]=py; arr[2]=0; arr[3]=bx; arr[4]=by; arr[5]=0;
      strings[i].geometry.attributes.position.needsUpdate = true;
    }
    const el = document.getElementById('stat-cradle');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  elastic e=0.999`;
    const _cur = sim.bob_positions()[1];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-gpu: Wave Field (1024 batched pendulums)
// =========================================
registerViz('ex-wavefield', () => {
  const sim = WasmWaveFieldSim.new();
  const N = sim.num_pendulums();
  const GRID = 32;
  const { scene, camera, controls, canvas } = createScene('ex-wavefield');
  camera.position.set(0, 2.5, 3.5);
  controls.target.set(0, 0, 0);

  const positions = new Float32Array(N * 3);
  const colors = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 4, vertexColors: true, sizeAttenuation: false })));
  const spacing = 0.08;

  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const angles = sim.angles();
    const vels = sim.velocities();
    for (let i = 0; i < N; i++) {
      const row = Math.floor(i / GRID), col = i % GRID;
      positions[i*3] = (col - GRID/2) * spacing;
      positions[i*3+1] = Math.sin(angles[i]) * 0.4;
      positions[i*3+2] = (row - GRID/2) * spacing;
      const v = Math.min(Math.abs(vels[i]) / 4.0, 1.0);
      colors[i*3] = 0.2 + v * 0.7;
      colors[i*3+1] = 0.25 * (1-v);
      colors[i*3+2] = 0.85 * (1-v);
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    const el = document.getElementById('stat-wavefield');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} envs  batched ABA`;
  }};
});


// =========================================
// phyz-gpu: Ensemble Divergence (100 double pendulums)
// =========================================
registerViz('ex-ensemble', () => {
  const sim = WasmEnsembleSim.new();
  const N = sim.num_instances();
  const { scene, camera, controls, canvas } = createScene('ex-ensemble');
  camera.position.set(0, -0.8, 7);
  controls.target.set(0, -0.8, 0);

  const dotGeo = new THREE.BufferGeometry();
  const dotPos = new Float32Array(N * 3);
  dotGeo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  scene.add(new THREE.Points(dotGeo, new THREE.PointsMaterial({ size: 4, color: ACCENT, sizeAttenuation: false, transparent: true, opacity: 0.85 })));

  const trailIdx = [0, 25, 50, 75, 99];
  const trailColors = [0x4a5fd7, 0x7c4dff, 0x2196f3, 0x00897b, 0xe74c3c];
  const trails = trailIdx.map((_, k) => makeTrail(400, trailColors[k], 0.55));
  trails.forEach(t => scene.add(t.line));
  scene.add(makeSphere(0.03, DARK));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const pos = sim.endpoint_positions();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*3]; dotPos[i*3+1] = pos[i*3+1]; dotPos[i*3+2] = pos[i*3+2];
    }
    dotGeo.attributes.position.needsUpdate = true;
    for (let k = 0; k < trailIdx.length; k++) {
      const i = trailIdx[k];
      pushTrail(trails[k], pos[i*3], pos[i*3+1], pos[i*3+2]);
    }
    const el = document.getElementById('stat-ensemble');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} envs  Lyapunov divergence`;
  }};
});


// =========================================
// phyz-gpu: Policy Search Grid (100 PD controllers)
// =========================================
registerViz('ex-policy', () => {
  const sim = WasmPolicyGridSim.new();
  const N = sim.num_envs();
  const GRID = 10;
  const { scene, camera, controls, canvas } = createScene('ex-policy');
  camera.position.set(0, 0, 5);
  controls.target.set(0, 0, 0);

  const cellSize = 0.28;
  const spheres = [], needles = [];
  for (let i = 0; i < N; i++) {
    const row = Math.floor(i / GRID), col = i % GRID;
    const x = (col - 4.5) * cellSize, y = (row - 4.5) * cellSize;
    const s = makeSphere(0.06, 0x888888);
    s.position.set(x, y, 0); scene.add(s); spheres.push(s);
    const nGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0, 0.1, 0)]);
    const nLine = new THREE.Line(nGeo, new THREE.LineBasicMaterial({ color: 0xffffff }));
    nLine.position.set(x, y, 0.01); scene.add(nLine); needles.push(nLine);
  }

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const rewards = sim.rewards();
    const angles = sim.angles();
    for (let i = 0; i < N; i++) {
      const r = rewards[i];
      const color = new THREE.Color();
      color.setHSL(r * 0.33, 0.75, 0.35 + r * 0.25);
      spheres[i].material.color = color;
      spheres[i].scale.setScalar(0.7 + r * 0.6);
      needles[i].rotation.z = -angles[i] + Math.PI;
    }
    const el = document.getElementById('stat-policy');
    const stable = rewards.filter(r => r > 0.9).length;
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${stable}/${N} balanced  kp/kd sweep`;
    const _cur = sim.angles()[0];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-particle: Granular Column
// =========================================
registerViz('ex-granular', () => {
  const sim = WasmMpmSim.granular_column();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-granular');
  camera.position.set(0, 0.4, 3.5);
  controls.target.set(0, 0.3, 0);
  scene.add(makeGround(2, 1, 0));

  const dotPos = new Float32Array(N * 3);
  const dotCol = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(dotCol, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 3, vertexColors: true, sizeAttenuation: false })));

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(48);
    const pos = sim.positions();
    const vel = sim.velocities();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
      const v = Math.min(Math.sqrt(vel[i*2]*vel[i*2] + vel[i*2+1]*vel[i*2+1]) / 2.0, 1.0);
      dotCol[i*3] = 0.6 + v*0.4; dotCol[i*3+1] = 0.35 - v*0.1; dotCol[i*3+2] = 0.1;
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    const el = document.getElementById('stat-granular');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} particles  Drucker-Prager`;
    const _cur = pos[1];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-particle: Fluid Dam Break
// =========================================
registerViz('ex-fluid', () => {
  const sim = WasmMpmSim.fluid_dam();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-fluid');
  camera.position.set(0, 0.4, 2.0);
  controls.target.set(0, 0.25, 0);
  scene.add(makeGround(1.5, 1, 0));

  const dotPos = new Float32Array(N * 3);
  const dotCol = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(dotCol, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 3, vertexColors: true, sizeAttenuation: false })));

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(48);
    const pos = sim.positions();
    const vel = sim.velocities();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
      const v = Math.min(Math.sqrt(vel[i*2]*vel[i*2] + vel[i*2+1]*vel[i*2+1]) / 3.0, 1.0);
      dotCol[i*3] = 0.1 + v*0.3; dotCol[i*3+1] = 0.3 + v*0.3; dotCol[i*3+2] = 0.8;
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    const el = document.getElementById('stat-fluid');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} particles  SPH fluid`;
    const _cur = pos[1];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-particle: Elastic Blob
// =========================================
registerViz('ex-elastic', () => {
  const sim = WasmMpmSim.elastic_blob();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-elastic');
  camera.position.set(0, 0.5, 2.5);
  controls.target.set(0, 0.3, 0);
  scene.add(makeGround(2, 1, 0));

  const dotPos = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 4, color: 0x2e7d32, sizeAttenuation: false })));

  const nSprings = sim.num_springs();
  const springPos = new Float32Array(nSprings * 6);
  const springGeo = new THREE.BufferGeometry();
  springGeo.setAttribute('position', new THREE.BufferAttribute(springPos, 3));
  scene.add(new THREE.LineSegments(springGeo, new THREE.LineBasicMaterial({ color: 0x4caf50, transparent: true, opacity: 0.3 })));

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(48);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
    }
    geo.attributes.position.needsUpdate = true;
    const ep = sim.spring_endpoints();
    for (let s = 0; s < nSprings; s++) {
      springPos[s*6] = ep[s*4]; springPos[s*6+1] = ep[s*4+1]; springPos[s*6+2] = 0;
      springPos[s*6+3] = ep[s*4+2]; springPos[s*6+4] = ep[s*4+3]; springPos[s*6+5] = 0;
    }
    springGeo.attributes.position.needsUpdate = true;
    const el = document.getElementById('stat-elastic');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} particles  ${nSprings} springs`;
    const _cur = pos[1];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-particle: Sand Hourglass
// =========================================
registerViz('ex-hourglass', () => {
  const sim = WasmHourglassSim.new();
  const N = sim.num_particles();
  const R = sim.particle_radius();
  const { scene, camera, controls, canvas } = createScene('ex-hourglass');
  camera.position.set(0, 0.55, 3.0);
  controls.target.set(0, 0.55, 0);
  controls.enableRotate = false;

  // Draw hourglass outline
  const outline = sim.outline();
  const outlineGeo = new THREE.BufferGeometry();
  const pts = [];
  for (let i = 0; i < outline.length; i += 2) {
    pts.push(new THREE.Vector3(outline[i], outline[i+1], -0.01));
  }
  pts.push(pts[0].clone()); // close the loop
  outlineGeo.setFromPoints(pts);
  scene.add(new THREE.Line(outlineGeo, new THREE.LineBasicMaterial({ color: 0x999999, transparent: true, opacity: 0.5 })));

  // Sand particles
  const dotPos = new Float32Array(N * 3);
  const dotCol = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(dotCol, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({
    size: 3, sizeAttenuation: false, vertexColors: true
  })));

  // Warm sand palette: darker when slow, brighter when fast
  return { scene, camera, controls, canvas, update() {
    sim.step_n(64);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
      // Color by height: warm sandy gradient
      const t = pos[i*2+1] / 1.1;
      dotCol[i*3]   = 0.85 + 0.1 * t; // R
      dotCol[i*3+1] = 0.65 + 0.15 * t; // G
      dotCol[i*3+2] = 0.3 + 0.15 * t;  // B
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    const el = document.getElementById('stat-hourglass');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} grains  DEM + funnel`;
  }};
});


// =========================================
// phyz-world: Random Chain
// =========================================
registerViz('ex-randchain', () => {
  const sim = WasmWorldSim.random_chain();
  const N = sim.nbodies();
  const lengths = sim.link_lengths();
  const { scene, camera, controls, canvas } = createScene('ex-randchain');
  camera.position.set(0, -1.5, 6);
  controls.target.set(0, -1.5, 0);

  scene.add(makeSphere(0.04, DARK));
  const hues = [0.0, 0.08, 0.16, 0.55, 0.7, 0.85];
  const rods = [], joints = [];
  for (let i = 0; i < N; i++) {
    const c = new THREE.Color().setHSL(hues[i], 0.6, 0.5);
    const rod = makeCyl(0.015, lengths[i], MUTED); scene.add(rod); rods.push(rod);
    const j = makeSphere(0.035, c); scene.add(j); joints.push(j);
  }
  const trail = makeTrail(400, 0x7c4dff, 0.25); scene.add(trail.line);

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const epos = sim.body_endpoint_positions();
    let px = 0, py = 0;
    for (let i = 0; i < N; i++) {
      const ex = epos[i*3], ey = epos[i*3+1];
      joints[i].position.set(ex, ey, 0);
      const dx = ex - px, dy = ey - py, len = Math.sqrt(dx*dx + dy*dy);
      rods[i].position.set((px+ex)/2, (py+ey)/2, 0);
      rods[i].rotation.z = Math.atan2(dx, -dy);
      rods[i].scale.y = len / lengths[i];
      px = ex; py = ey;
    }
    pushTrail(trail, px, py, 0);
    const el = document.getElementById('stat-randchain');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} links  procedural gen`;
    const _cur = px;
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-world: Phase Portrait
// =========================================
registerViz('ex-phase', () => {
  const sim = WasmWorldSim.phase_portrait();
  const { scene, camera, controls, canvas } = createScene('ex-phase');
  camera.position.set(0, 0, 5);
  controls.target.set(0, 0, 0);

  const axMat = new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.3 });
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-2,0,0), new THREE.Vector3(2,0,0)]), axMat));
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,-1.5,0), new THREE.Vector3(0,1.5,0)]), axMat));
  const trail = makeTrail(800, ACCENT, 0.5); scene.add(trail.line);
  const dot = makeSphere(0.06, ACCENT); scene.add(dot);

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const q = sim.q(), v = sim.v();
    dot.position.set(q * 0.5, v * 0.2, 0);
    pushTrail(trail, q * 0.5, v * 0.2, 0);
    const el = document.getElementById('stat-phase');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  q=${q.toFixed(2)}  v=${v.toFixed(2)}`;
    const _cur = sim.q();
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-world: Tendon Actuated
// =========================================
registerViz('ex-tendon', () => {
  const sim = WasmWorldSim.tendon_actuated();
  const N = sim.nbodies();
  const L = sim.link_lengths()[0];
  const { scene, camera, controls, canvas } = createScene('ex-tendon');
  camera.position.set(0, -1, 7);
  controls.target.set(0, -1, 0);

  scene.add(makeSphere(0.04, DARK));
  const rods = [], joints = [];
  for (let i = 0; i < N; i++) {
    const rod = makeCyl(0.018, L, MUTED); scene.add(rod); rods.push(rod);
    const j = makeSphere(0.035, i === N-1 ? 0xe74c3c : DARK); scene.add(j); joints.push(j);
  }
  const tendonGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
  const tendonLine = new THREE.Line(tendonGeo, new THREE.LineBasicMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.6 }));
  scene.add(tendonLine);
  const trail = makeTrail(300, 0xe74c3c, 0.2); scene.add(trail.line);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const epos = sim.body_endpoint_positions();
    let px = 0, py = 0;
    for (let i = 0; i < N; i++) {
      const ex = epos[i*3], ey = epos[i*3+1];
      joints[i].position.set(ex, ey, 0);
      const dx = ex-px, dy = ey-py, len = Math.sqrt(dx*dx+dy*dy);
      rods[i].position.set((px+ex)/2, (py+ey)/2, 0);
      rods[i].rotation.z = Math.atan2(dx, -dy);
      rods[i].scale.y = len / L;
      px = ex; py = ey;
    }
    pushTrail(trail, px, py, 0);
    const ta = tendonLine.geometry.attributes.position.array;
    ta[0] = px; ta[1] = py; ta[2] = 0;
    ta[3] = 0; ta[4] = 0; ta[5] = 0;
    tendonLine.geometry.attributes.position.needsUpdate = true;
    const el = document.getElementById('stat-tendon');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} links  sinusoidal ctrl`;
  }};
});


// =========================================
// phyz-world: Tendon Gripper
// =========================================
registerViz('ex-gripper', () => {
  const sim = WasmGripperSim.new();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-gripper');
  camera.position.set(0, 0.1, 3.5);
  controls.target.set(0, 0.1, 0);

  // Base (palm)
  const base = makeSphere(0.05, DARK); scene.add(base);
  // Left finger joints + rods
  const lJoints = []; const lRods = [];
  for (let i = 0; i < 3; i++) {
    const j = makeSphere(0.03, ACCENT); scene.add(j); lJoints.push(j);
    const r = makeCyl(0.012, 0.25, MUTED); scene.add(r); lRods.push(r);
  }
  // Right finger joints + rods
  const rJoints = []; const rRods = [];
  for (let i = 0; i < 3; i++) {
    const j = makeSphere(0.03, 0x7c4dff); scene.add(j); rJoints.push(j);
    const r = makeCyl(0.012, 0.25, MUTED); scene.add(r); rRods.push(r);
  }
  // Ball
  const ball = makeSphere(0.06, 0xe74c3c); scene.add(ball);
  scene.add(makeGround(2, 1, 0));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const pos = sim.positions();
    base.position.set(pos[0], pos[1], 0);
    // Left finger
    let ppx = pos[0], ppy = pos[1];
    for (let i = 0; i < 3; i++) {
      const x = pos[(1+i)*2], y = pos[(1+i)*2+1];
      lJoints[i].position.set(x, y, 0);
      const dx = x - ppx, dy = y - ppy, len = Math.sqrt(dx*dx+dy*dy);
      lRods[i].position.set((ppx+x)/2, (ppy+y)/2, 0);
      lRods[i].rotation.z = Math.atan2(dx, -dy);
      lRods[i].scale.y = Math.max(len / 0.25, 0.01);
      ppx = x; ppy = y;
    }
    // Right finger
    ppx = pos[0]; ppy = pos[1];
    for (let i = 0; i < 3; i++) {
      const x = pos[(4+i)*2], y = pos[(4+i)*2+1];
      rJoints[i].position.set(x, y, 0);
      const dx = x - ppx, dy = y - ppy, len = Math.sqrt(dx*dx+dy*dy);
      rRods[i].position.set((ppx+x)/2, (ppy+y)/2, 0);
      rRods[i].rotation.z = Math.atan2(dx, -dy);
      rRods[i].scale.y = Math.max(len / 0.25, 0.01);
      ppx = x; ppy = y;
    }
    // Ball
    ball.position.set(pos[14], pos[15], 0);
    const el = document.getElementById('stat-gripper');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  2 fingers  tendon-driven`;
  }};
});


// =========================================
// phyz-em: Helper
// =========================================
function makeEmViz(canvasId, sim, statId, label) {
  const N = sim.grid_size();
  const { scene, camera, controls, canvas } = createScene(canvasId);
  camera.position.set(0, 0, 2.2);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const data = new Uint8Array(N * N * 4);
  const smooth = new Float32Array(N * N); // temporal smoothing buffer
  const texture = new THREE.DataTexture(data, N, N, THREE.RGBAFormat);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: texture })));
  const mask = sim.mask_data();
  // Neutral background matching page bg (#faf9f7 ~ 250,249,247)
  const bg = 247;

  return { scene, camera, controls, canvas, update() {
    sim.step_n(4);
    const field = sim.field();
    for (let i = 0; i < N * N; i++) {
      const m = mask[i];
      if (m < 0.5) {
        data[i*4] = 50; data[i*4+1] = 50; data[i*4+2] = 55; data[i*4+3] = 255;
      } else {
        // Exponential smoothing to avoid flashing (alpha=0.3)
        smooth[i] = smooth[i] * 0.7 + field[i] * 0.3;
        const v = smooth[i];
        const s = Math.min(Math.abs(v) * 1.8, 1.0);
        // Soft diverging colormap: warm beige -> muted rose / muted blue
        if (v > 0) {
          data[i*4]   = Math.floor(bg + (200 - bg) * s); // rose red
          data[i*4+1] = Math.floor(bg + (160 - bg) * s);
          data[i*4+2] = Math.floor(bg + (150 - bg) * s);
        } else {
          data[i*4]   = Math.floor(bg + (150 - bg) * s);
          data[i*4+1] = Math.floor(bg + (165 - bg) * s);
          data[i*4+2] = Math.floor(bg + (210 - bg) * s); // steel blue
        }
        data[i*4+3] = 255;
      }
    }
    texture.needsUpdate = true;
    const el = document.getElementById(statId);
    if (el) el.textContent = `t=${sim.time().toFixed(2)}s  ${N}x${N} Yee grid  ${label}`;
  }};
}

registerViz('ex-dipole', () => makeEmViz('ex-dipole', WasmEmSim.dipole(), 'stat-dipole', 'PML boundary'));
registerViz('ex-guide', () => makeEmViz('ex-guide', WasmEmSim.waveguide(), 'stat-guide', 'TM waveguide'));
registerViz('ex-slit', () => makeEmViz('ex-slit', WasmEmSim.double_slit(), 'stat-slit', 'interference'));


// =========================================
// phyz-md: Helper for 2D particle viz
// =========================================
function makeMdViz(canvasId, sim, statId, label, baseColor) {
  const N = sim.num_particles();
  const bs = sim.box_size();
  const { scene, camera, controls, canvas } = createScene(canvasId);
  camera.position.set(bs/2, bs/2, bs * 2);
  controls.target.set(bs/2, bs/2, 0);

  const boxPts = [
    new THREE.Vector3(0,0,0), new THREE.Vector3(bs,0,0),
    new THREE.Vector3(bs,bs,0), new THREE.Vector3(0,bs,0), new THREE.Vector3(0,0,0)
  ];
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(boxPts),
    new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.3 })));

  const dotPos = new Float32Array(N * 3);
  const dotCol = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(dotCol, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 4, vertexColors: true, sizeAttenuation: false })));

  const nBonds = sim.num_bonds();
  let bondGeo = null, bondPos = null;
  if (nBonds > 0) {
    bondPos = new Float32Array(nBonds * 6);
    bondGeo = new THREE.BufferGeometry();
    bondGeo.setAttribute('position', new THREE.BufferAttribute(bondPos, 3));
    scene.add(new THREE.LineSegments(bondGeo, new THREE.LineBasicMaterial({ color: baseColor, transparent: true, opacity: 0.4 })));
  }
  const bc = new THREE.Color(baseColor);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const pos = sim.positions();
    const vel = sim.velocities();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
      const v = Math.min(Math.sqrt(vel[i*2]*vel[i*2] + vel[i*2+1]*vel[i*2+1]) / 4.0, 1.0);
      dotCol[i*3] = bc.r * (0.5 + v*0.5); dotCol[i*3+1] = bc.g * (0.5 + v*0.5); dotCol[i*3+2] = bc.b * (0.5 + v*0.5);
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    if (nBonds > 0) {
      const ep = sim.bond_endpoints();
      for (let s = 0; s < nBonds; s++) {
        bondPos[s*6] = ep[s*4]; bondPos[s*6+1] = ep[s*4+1]; bondPos[s*6+2] = 0;
        bondPos[s*6+3] = ep[s*4+2]; bondPos[s*6+4] = ep[s*4+3]; bondPos[s*6+5] = 0;
      }
      bondGeo.attributes.position.needsUpdate = true;
    }
    const T = sim.temperature();
    const el = document.getElementById(statId);
    if (el) el.textContent = `t=${sim.time().toFixed(2)}s  T=${T.toFixed(3)}  ${label}`;
  }};
}

registerViz('ex-argon', () => makeMdViz('ex-argon', WasmMdSim.argon_gas(), 'stat-argon', 'LJ 12-6', ACCENT));
registerViz('ex-crystal', () => makeMdViz('ex-crystal', WasmMdSim.crystal(), 'stat-crystal', 'phonons', 0x00897b));
registerViz('ex-polymer', () => makeMdViz('ex-polymer', WasmMdSim.polymer(), 'stat-polymer', 'bonded chain', 0x7c4dff));

// =========================================
// phyz-md: Cooling Gas → Crystal Formation
// =========================================
registerViz('ex-cooling', () => {
  const sim = WasmMdSim.cooling_gas();
  const N = sim.num_particles();
  const bs = sim.box_size();
  const { scene, camera, controls, canvas } = createScene('ex-cooling');
  camera.position.set(bs/2, bs/2, 2.5);
  controls.target.set(bs/2, bs/2, 0);
  controls.enableRotate = false;

  // Box outline
  const boxPts = [
    new THREE.Vector3(0,0,0), new THREE.Vector3(bs,0,0),
    new THREE.Vector3(bs,bs,0), new THREE.Vector3(0,bs,0), new THREE.Vector3(0,0,0)
  ];
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(boxPts),
    new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.3 })));

  const dotPos = new Float32Array(N * 3);
  const dotCol = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(dotCol, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 5, vertexColors: true, sizeAttenuation: false })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const pos = sim.positions();
    const vel = sim.velocities();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
      // Color by kinetic energy: hot=red/orange, cold=blue/purple
      const ke = vel[i*2]*vel[i*2] + vel[i*2+1]*vel[i*2+1];
      const t = Math.min(ke / 8.0, 1.0); // normalize
      // Blue (cold) → Red (hot) via purple midpoint
      dotCol[i*3]   = t;                       // R
      dotCol[i*3+1] = 0.1 + 0.2 * (1.0 - t);  // G
      dotCol[i*3+2] = 1.0 - t;                 // B
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    const T = sim.temperature();
    const el = document.getElementById('stat-cooling');
    if (el) el.textContent = `t=${sim.time().toFixed(2)}s  T=${T.toFixed(3)}  gas→crystal cooling`;
  }};
});


// =========================================
// phyz-qft: Helper for lattice heatmap viz
// =========================================
function makeQftViz(canvasId, sim, statId, labelFn) {
  const N = sim.lattice_size();
  const { scene, camera, controls, canvas } = createScene(canvasId);
  camera.position.set(0, 0, 2.2);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const data = new Uint8Array(N * N * 4);
  const smooth = new Float32Array(N * N); // temporal smoothing
  const texture = new THREE.DataTexture(data, N, N, THREE.RGBAFormat);
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: texture })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(3);
    const plaq = sim.plaquettes();
    for (let i = 0; i < N * N; i++) {
      const raw = (plaq[i] + 1) * 0.5;
      // Smooth over time to avoid flicker
      smooth[i] = smooth[i] * 0.6 + raw * 0.4;
      const t = Math.max(0, Math.min(1, smooth[i]));
      // Muted palette: dark indigo -> teal -> warm sand
      data[i*4]   = Math.floor(45 + t * 195);
      data[i*4+1] = Math.floor(40 + t * 180);
      data[i*4+2] = Math.floor(80 * (1-t) + 90 * t);
      data[i*4+3] = 255;
    }
    texture.needsUpdate = true;
    const el = document.getElementById(statId);
    if (el) el.textContent = labelFn(sim);
  }};
}

registerViz('ex-plaq', () => makeQftViz('ex-plaq', WasmQftSim.u1_plaquette(), 'stat-plaq',
  s => `sweep ${s.time().toFixed(0)}  <P>=${s.average_plaquette().toFixed(3)}  beta=${s.beta().toFixed(1)}`
));

registerViz('ex-wilson', () => {
  const sim = WasmQftSim.wilson_loops();
  const N = sim.lattice_size();
  const { scene, camera, controls, canvas } = createScene('ex-wilson');
  camera.position.set(0, 0, 2.2);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const data = new Uint8Array(N * N * 4);
  const smooth = new Float32Array(N * N);
  const texture = new THREE.DataTexture(data, N, N, THREE.RGBAFormat);
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: texture })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(3);
    const plaq = sim.plaquettes();
    for (let i = 0; i < N * N; i++) {
      const raw = (plaq[i] + 1) * 0.5;
      smooth[i] = smooth[i] * 0.6 + raw * 0.4;
      const t = Math.max(0, Math.min(1, smooth[i]));
      data[i*4]   = Math.floor(45 + t * 195);
      data[i*4+1] = Math.floor(40 + t * 180);
      data[i*4+2] = Math.floor(80 * (1-t) + 90 * t);
      data[i*4+3] = 255;
    }
    texture.needsUpdate = true;
    const w11 = sim.wilson_loop(1,1);
    const w22 = sim.wilson_loop(2,2);
    const w33 = sim.wilson_loop(3,3);
    const el = document.getElementById('stat-wilson');
    if (el) el.textContent = `W(1,1)=${w11.toFixed(2)}  W(2,2)=${w22.toFixed(2)}  W(3,3)=${w33.toFixed(2)}`;
  }};
});

registerViz('ex-phasescan', () => makeQftViz('ex-phasescan', WasmQftSim.phase_scan(), 'stat-phasescan',
  s => `beta=${s.beta().toFixed(2)}  <P>=${s.average_plaquette().toFixed(3)}  sweep ${s.time().toFixed(0)}`
));

// =========================================
// phyz-coupling: Lorentz Spiral
// =========================================
registerViz('ex-spiral', () => {
  const sim = WasmLorentzSim.spiral();
  const { scene, camera, controls, canvas } = createScene('ex-spiral');
  camera.position.set(3, 1, 2);
  controls.target.set(0, 0, 1.5);
  controls.enableRotate = true;

  const dot = makeSphere(0.06, ACCENT);
  scene.add(dot);
  const trailMax = 600;
  const trailGeo = new THREE.BufferGeometry();
  const trailPos = new Float32Array(trailMax * 3);
  trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
  trailGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(trailGeo, new THREE.LineBasicMaterial({ color: ACCENT, transparent: true, opacity: 0.4 })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(4);
    const pos = sim.position();
    dot.position.set(pos[0], pos[1], pos[2]);
    const trail = sim.trail();
    const n = sim.trail_len();
    for (let i = 0; i < n; i++) {
      trailPos[i*3] = trail[i*3]; trailPos[i*3+1] = trail[i*3+1]; trailPos[i*3+2] = trail[i*3+2];
    }
    trailGeo.attributes.position.needsUpdate = true;
    trailGeo.setDrawRange(0, n);
    const el = document.getElementById('stat-spiral');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  v=${sim.speed().toFixed(2)}  Boris integrator`;
  }};
});


// =========================================
// phyz-coupling: Crossed Fields (E x B drift)
// =========================================
registerViz('ex-crossed', () => {
  const sim = WasmLorentzSim.crossed_fields();
  const { scene, camera, controls, canvas } = createScene('ex-crossed');
  camera.position.set(0, 1, 5);
  controls.target.set(0, 1, 0);

  const dot = makeSphere(0.06, 0xe74c3c);
  scene.add(dot);
  const trailMax = 600;
  const trailGeo = new THREE.BufferGeometry();
  const trailPos = new Float32Array(trailMax * 3);
  trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
  trailGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(trailGeo, new THREE.LineBasicMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.4 })));

  // E and B field arrows
  const arrowE = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(-2,0,0), 1.0, 0x2e7d32, 0.15, 0.1);
  const arrowB = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(-2,0,0), 1.0, ACCENT, 0.15, 0.1);
  scene.add(arrowE); scene.add(arrowB);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(4);
    const pos = sim.position();
    dot.position.set(pos[0], pos[1], pos[2]);
    const trail = sim.trail();
    const n = sim.trail_len();
    for (let i = 0; i < n; i++) {
      trailPos[i*3] = trail[i*3]; trailPos[i*3+1] = trail[i*3+1]; trailPos[i*3+2] = trail[i*3+2];
    }
    trailGeo.attributes.position.needsUpdate = true;
    trailGeo.setDrawRange(0, n);
    const el = document.getElementById('stat-crossed');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  E×B drift  v=${sim.speed().toFixed(2)}`;
  }};
});


// =========================================
// phyz-coupling: Magnetic Mirror
// =========================================
registerViz('ex-mirror', () => {
  const sim = WasmLorentzSim.magnetic_mirror();
  const { scene, camera, controls, canvas } = createScene('ex-mirror');
  camera.position.set(2, 1, 5);
  controls.target.set(0, 0, 0);

  const dot = makeSphere(0.06, 0x7c4dff);
  scene.add(dot);
  const trailMax = 800;
  const trailGeo = new THREE.BufferGeometry();
  const trailPos = new Float32Array(trailMax * 3);
  trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
  trailGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(trailGeo, new THREE.LineBasicMaterial({ color: 0x7c4dff, transparent: true, opacity: 0.35 })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(6);
    const pos = sim.position();
    dot.position.set(pos[0], pos[1], pos[2]);
    const trail = sim.trail();
    const n = sim.trail_len();
    for (let i = 0; i < n; i++) {
      trailPos[i*3] = trail[i*3]; trailPos[i*3+1] = trail[i*3+1]; trailPos[i*3+2] = trail[i*3+2];
    }
    trailGeo.attributes.position.needsUpdate = true;
    trailGeo.setDrawRange(0, n);
    const el = document.getElementById('stat-mirror');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  magnetic mirror  converging B`;
  }};
});


// =========================================
// phyz-gravity: Binary Orbit
// =========================================
registerViz('ex-binary', () => {
  const sim = WasmGravitySim.binary_orbit();
  const { scene, camera, controls, canvas } = createScene('ex-binary');
  camera.position.set(0, 0, 7);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const masses = sim.masses();
  const s1 = makeSphere(0.12, ACCENT); scene.add(s1);
  const s2 = makeSphere(0.12, 0xe74c3c); scene.add(s2);
  const t1 = makeTrail(500, ACCENT, 0.3); scene.add(t1.line);
  const t2 = makeTrail(500, 0xe74c3c, 0.3); scene.add(t2.line);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const pos = sim.positions();
    s1.position.set(pos[0], pos[1], 0);
    s2.position.set(pos[2], pos[3], 0);
    pushTrail(t1, pos[0], pos[1], 0);
    pushTrail(t2, pos[2], pos[3], 0);
    const el = document.getElementById('stat-binary');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  2-body  Newtonian gravity`;
  }};
});


// =========================================
// phyz-gravity: Solar System
// =========================================
registerViz('ex-solar', () => {
  const sim = WasmGravitySim.solar_system();
  const N = sim.num_bodies();
  const { scene, camera, controls, canvas } = createScene('ex-solar');
  camera.position.set(0, 0, 14);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const colors = [0xffcc00, 0xe74c3c, ACCENT, 0x2e7d32, 0x7c4dff, 0x00897b];
  const radii = [0.2, 0.06, 0.08, 0.1, 0.07, 0.055];
  const spheres = [], trails = [];
  for (let i = 0; i < N; i++) {
    const s = makeSphere(radii[i], colors[i]); scene.add(s); spheres.push(s);
    if (i > 0) { const t = makeTrail(400, colors[i], 0.25); scene.add(t.line); trails.push(t); }
  }

  return { scene, camera, controls, canvas, update() {
    sim.step_n(32);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) {
      spheres[i].position.set(pos[i*2], pos[i*2+1], 0);
      if (i > 0) pushTrail(trails[i-1], pos[i*2], pos[i*2+1], 0);
    }
    const el = document.getElementById('stat-solar');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} bodies  Kepler orbits`;
  }};
});


// =========================================
// phyz-gravity: Precession
// =========================================
registerViz('ex-precess', () => {
  const sim = WasmGravitySim.precession();
  const { scene, camera, controls, canvas } = createScene('ex-precess');
  camera.position.set(0, 0, 6);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const sun = makeSphere(0.15, 0xffcc00); scene.add(sun);
  const planet = makeSphere(0.06, 0xe74c3c); scene.add(planet);
  const trail = makeTrail(1200, 0xe74c3c, 0.3); scene.add(trail.line);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(32);
    const pos = sim.positions();
    sun.position.set(pos[0], pos[1], 0);
    planet.position.set(pos[2], pos[3], 0);
    pushTrail(trail, pos[2], pos[3], 0);
    const el = document.getElementById('stat-precess');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  perihelion precession  post-Newtonian`;
  }};
});


// =========================================
// phyz-gravity: Galaxy Collision
// =========================================
registerViz('ex-galaxy', () => {
  const sim = WasmGravitySim.galaxy_collision();
  const N = sim.num_bodies();
  const { scene, camera, controls, canvas } = createScene('ex-galaxy');
  camera.position.set(0, 0, 16);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  // Point cloud for stars — colored by velocity
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(N * 3);
  const colors = new Float32Array(N * 3);
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  const points = new THREE.Points(geo, new THREE.PointsMaterial({
    size: 3, sizeAttenuation: false, vertexColors: true, transparent: true, opacity: 0.9
  }));
  scene.add(points);

  // Core spheres (larger, brighter)
  const coreA = makeSphere(0.12, 0xffcc00); scene.add(coreA);
  const coreB = makeSphere(0.12, 0x4fc3f7); scene.add(coreB);

  // Velocity→color: low=cool blue, high=warm yellow/white
  function speedColor(v, maxV) {
    const t = Math.min(v / maxV, 1.0);
    // Blue (0.3,0.4,0.8) → White-yellow (1,0.95,0.7)
    return [0.3 + 0.7 * t, 0.4 + 0.55 * t, 0.8 - 0.1 * t];
  }

  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const pos = sim.positions();
    const spd = sim.speeds();

    // Find max speed for normalization
    let maxV = 0.1;
    for (let i = 2; i < N; i++) { if (spd[i] > maxV) maxV = spd[i]; }

    // Update cores
    coreA.position.set(pos[0], pos[1], 0);
    coreB.position.set(pos[2], pos[3], 0);

    // Update point cloud
    for (let i = 0; i < N; i++) {
      positions[i*3]     = pos[i*2];
      positions[i*3 + 1] = pos[i*2 + 1];
      positions[i*3 + 2] = 0;
      const [r, g, b] = speedColor(spd[i], maxV);
      colors[i*3] = r; colors[i*3+1] = g; colors[i*3+2] = b;
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;

    const el = document.getElementById('stat-galaxy');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} bodies  tidal interaction`;
  }};
});


// =========================================
// phyz-gravity: Interactive Gravity Sandbox
// =========================================
registerViz('ex-sandbox', () => {
  const sim = WasmGravitySandboxSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-sandbox');
  camera.position.set(0, 0, 10);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const bodyGroup = new THREE.Group();
  scene.add(bodyGroup);
  const trailGroup = new THREE.Group();
  scene.add(trailGroup);

  const bodyColors = [0xffcc00, 0xe74c3c, ACCENT, 0x2e7d32, 0x7c4dff, 0x00897b, 0xff9800, 0x9c27b0];
  let spheres = [];
  let trails = [];

  // Central star
  const star = makeSphere(0.15, 0xffcc00);
  bodyGroup.add(star);
  spheres.push(star);
  trails.push(makeTrail(400, 0xffcc00, 0.2));
  trailGroup.add(trails[0].line);

  // Click to add body
  const raycaster = new THREE.Raycaster();
  const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
  const mouse = new THREE.Vector2();
  const intersect = new THREE.Vector3();

  canvas.style.pointerEvents = 'auto';
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    raycaster.ray.intersectPlane(plane, intersect);
    const x = intersect.x, y = intersect.y;
    // Orbital velocity perpendicular to radius from center
    const r = Math.sqrt(x * x + y * y);
    const v = r > 0.1 ? Math.sqrt(10.0 * 10.0 / r) * 0.7 : 0;
    const vx = r > 0.1 ? -v * (y / r) : 0;
    const vy = r > 0.1 ? v * (x / r) : 0;
    sim.add_body(x, y, vx, vy, 0.3);
    const idx = sim.num_bodies() - 1;
    const color = bodyColors[idx % bodyColors.length];
    const s = makeSphere(0.05, color);
    bodyGroup.add(s); spheres.push(s);
    const t = makeTrail(400, color, 0.25);
    trailGroup.add(t.line); trails.push(t);
  });

  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const N = sim.num_bodies();
    const pos = sim.positions();
    const masses = sim.masses();

    // Rebuild if merges happened (bodies removed)
    while (spheres.length > N) {
      const s = spheres.pop();
      bodyGroup.remove(s);
      const t = trails.pop();
      trailGroup.remove(t.line);
    }

    for (let i = 0; i < N; i++) {
      if (i < spheres.length) {
        spheres[i].position.set(pos[i*2], pos[i*2+1], 0);
        // Scale sphere by mass
        const scale = Math.max(0.5, Math.cbrt(masses[i] / 0.3));
        spheres[i].scale.setScalar(scale);
        // Update trail
        const tdata = sim.trail_for(i);
        if (tdata.length >= 4 && i < trails.length) {
          const tpts = trails[i].line.geometry.attributes.position;
          const maxPts = tpts.count;
          const nPts = Math.min(tdata.length / 2, maxPts);
          const offset = tdata.length / 2 - nPts;
          for (let j = 0; j < nPts; j++) {
            tpts.array[j*3] = tdata[(offset + j) * 2];
            tpts.array[j*3+1] = tdata[(offset + j) * 2 + 1];
            tpts.array[j*3+2] = 0;
          }
          trails[i].line.geometry.setDrawRange(0, nPts);
          tpts.needsUpdate = true;
        }
      }
    }
    const el = document.getElementById('stat-sandbox');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} bodies  click to add`;
  }};
});


// =========================================
// phyz-guardian: Energy Monitor
// =========================================
registerViz('ex-emonitor', () => {
  const sim = WasmGuardianSim.energy_monitor();
  const L = sim.length();
  const { scene, camera, controls, canvas } = createScene('ex-emonitor');
  camera.position.set(0, -0.3, 4.5);
  controls.target.set(0, -0.5, 0);

  scene.add(makeSphere(0.04, DARK));
  const rod = makeCyl(0.02, L, MUTED); scene.add(rod);
  const bob = makeSphere(0.08, ACCENT); scene.add(bob);

  // Energy bars (3D boxes for KE, PE, Total)
  const barKE = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 0.05), new THREE.MeshStandardMaterial({ color: 0xe74c3c }));
  const barPE = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 0.05), new THREE.MeshStandardMaterial({ color: ACCENT }));
  const barTot = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 0.05), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
  barKE.position.set(1.5, 0, 0); barPE.position.set(1.7, 0, 0); barTot.position.set(1.9, 0, 0);
  scene.add(barKE); scene.add(barPE); scene.add(barTot);

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const q = sim.q_val();
    const bx = L * Math.sin(q), by = -L * Math.cos(q);
    bob.position.set(bx, by, 0);
    rod.position.set(bx/2, by/2, 0);
    rod.rotation.z = q;

    const ke = sim.ke(), pe = sim.pe(), tot = sim.total_energy();
    const maxE = Math.max(tot * 1.2, 0.1);
    barKE.scale.y = Math.max(ke / maxE, 0.01); barKE.position.y = -1 + barKE.scale.y * 0.5;
    barPE.scale.y = Math.max(pe / maxE, 0.01); barPE.position.y = -1 + barPE.scale.y * 0.5;
    barTot.scale.y = Math.max(tot / maxE, 0.01); barTot.position.y = -1 + barTot.scale.y * 0.5;

    const el = document.getElementById('stat-emonitor');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  KE=${ke.toFixed(3)}  PE=${pe.toFixed(3)}  E=${tot.toFixed(3)}`;
    const _cur = sim.q_val();
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-guardian: Adaptive dt
// =========================================
registerViz('ex-adaptdt', () => {
  const sim = WasmGuardianSim.adaptive_dt();
  const L = sim.length();
  const { scene, camera, controls, canvas } = createScene('ex-adaptdt');
  camera.position.set(0, -0.3, 8);
  controls.target.set(0, -0.5, 0);

  // Fixed dt pendulum (left)
  const pivot1 = makeSphere(0.03, DARK); pivot1.position.set(-1.0, 0, 0); scene.add(pivot1);
  const rod1 = makeCyl(0.018, L, 0xe74c3c); scene.add(rod1);
  const bob1 = makeSphere(0.07, 0xe74c3c); scene.add(bob1);

  // Adaptive dt pendulum (right)
  const pivot2 = makeSphere(0.03, DARK); pivot2.position.set(1.0, 0, 0); scene.add(pivot2);
  const rod2 = makeCyl(0.018, L, 0x2e7d32); scene.add(rod2);
  const bob2 = makeSphere(0.07, 0x2e7d32); scene.add(bob2);

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(4);
    const q1 = sim.q_val(), q2 = sim.q2_val();
    const bx1 = -1.0 + L*Math.sin(q1), by1 = -L*Math.cos(q1);
    bob1.position.set(bx1, by1, 0);
    rod1.position.set(-1.0 + L*Math.sin(q1)/2, -L*Math.cos(q1)/2, 0);
    rod1.rotation.z = q1;

    const bx2 = 1.0 + L*Math.sin(q2), by2 = -L*Math.cos(q2);
    bob2.position.set(bx2, by2, 0);
    rod2.position.set(1.0 + L*Math.sin(q2)/2, -L*Math.cos(q2)/2, 0);
    rod2.rotation.z = q2;

    const hist1 = sim.total_history();
    const hist2 = sim.total_history2();
    const e1 = hist1.length > 0 ? hist1[hist1.length-1] : 0;
    const e2 = hist2.length > 0 ? hist2[hist2.length-1] : 0;
    const el = document.getElementById('stat-adaptdt');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  fixed E=${e1.toFixed(3)}  adaptive E=${e2.toFixed(3)}`;
    const _cur = sim.q_val();
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-guardian: Correction Demo
// =========================================
registerViz('ex-correction', () => {
  const sim = WasmGuardianSim.correction_demo();
  const L = sim.length();
  const { scene, camera, controls, canvas } = createScene('ex-correction');
  camera.position.set(0, -0.3, 4.5);
  controls.target.set(0, -0.5, 0);

  scene.add(makeSphere(0.04, DARK));
  const rod = makeCyl(0.02, L, MUTED); scene.add(rod);
  const bob = makeSphere(0.08, 0x2e7d32); scene.add(bob);
  const trail = makeTrail(300, 0x2e7d32, 0.25); scene.add(trail.line);

  // Energy line chart (using points)
  const histMax = 200;
  const histPos = new Float32Array(histMax * 3);
  const histGeo = new THREE.BufferGeometry();
  histGeo.setAttribute('position', new THREE.BufferAttribute(histPos, 3));
  histGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(histGeo, new THREE.LineBasicMaterial({ color: 0x2e7d32 })));

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const q = sim.q_val();
    const bx = L*Math.sin(q), by = -L*Math.cos(q);
    bob.position.set(bx, by, 0);
    rod.position.set(bx/2, by/2, 0);
    rod.rotation.z = q;
    pushTrail(trail, bx, by, 0);

    const hist = sim.total_history();
    const n = hist.length;
    const e0 = sim.e0();
    for (let i = 0; i < n; i++) {
      histPos[i*3] = 1.2 + i * (1.0/histMax);
      histPos[i*3+1] = -1.0 + (hist[i] / (e0 * 2)) * 1.5;
      histPos[i*3+2] = 0;
    }
    histGeo.attributes.position.needsUpdate = true;
    histGeo.setDrawRange(0, n);

    const el = document.getElementById('stat-correction');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  E=${sim.total_energy().toFixed(4)}  E₀=${e0.toFixed(4)}  guardian ON`;
    const _cur = sim.q_val();
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-lbm: Helper for LBM heatmap viz
// =========================================
function makeLbmViz(canvasId, sim, statId, label, useVorticity) {
  const nx = sim.grid_nx(), ny = sim.grid_ny();
  const { scene, camera, controls, canvas } = createScene(canvasId);
  camera.position.set(0, 0, 2.2);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const texW = nx, texH = ny;
  const data = new Uint8Array(texW * texH * 4);
  const smooth = new Float32Array(texW * texH);
  const texture = new THREE.DataTexture(data, texW, texH, THREE.RGBAFormat);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  const aspect = nx / ny;
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2 * aspect / Math.max(aspect, 1), 2 / Math.max(1, 1/aspect)), new THREE.MeshBasicMaterial({ map: texture })));
  const bg = 247;

  return { scene, camera, controls, canvas, update() {
    sim.step_n(4);
    const field = useVorticity ? sim.vorticity_field() : sim.velocity_field();
    for (let i = 0; i < texW * texH; i++) {
      if (field[i] < 0 && !useVorticity) {
        // Obstacle
        data[i*4] = 50; data[i*4+1] = 50; data[i*4+2] = 55; data[i*4+3] = 255;
      } else {
        smooth[i] = smooth[i] * 0.7 + field[i] * 0.3;
        if (useVorticity) {
          const v = smooth[i];
          const s = Math.min(Math.abs(v) * 300, 1.0);
          if (v > 0) {
            data[i*4]   = Math.floor(bg + (200 - bg) * s);
            data[i*4+1] = Math.floor(bg + (100 - bg) * s);
            data[i*4+2] = Math.floor(bg + (100 - bg) * s);
          } else {
            data[i*4]   = Math.floor(bg + (100 - bg) * s);
            data[i*4+1] = Math.floor(bg + (100 - bg) * s);
            data[i*4+2] = Math.floor(bg + (200 - bg) * s);
          }
        } else {
          const s = Math.min(smooth[i] * 8.0, 1.0);
          // Warm velocity colormap
          data[i*4]   = Math.floor(bg * (1-s) + 200 * s);
          data[i*4+1] = Math.floor(bg * (1-s) + 80 * s);
          data[i*4+2] = Math.floor(bg * (1-s) + 60 * s);
        }
        data[i*4+3] = 255;
      }
    }
    texture.needsUpdate = true;
    const el = document.getElementById(statId);
    if (el) el.textContent = `t=${sim.time().toFixed(0)}  ${nx}×${ny} D2Q9  ${label}`;
  }};
}

registerViz('ex-cavity', () => makeLbmViz('ex-cavity', WasmLbmSim.cavity_flow(), 'stat-cavity', 'lid-driven cavity', false));
registerViz('ex-channel', () => makeLbmViz('ex-channel', WasmLbmSim.channel_flow(), 'stat-channel', 'Poiseuille flow', false));
registerViz('ex-vortex', () => makeLbmViz('ex-vortex', WasmLbmSim.vortex_street(), 'stat-vortex', 'von Karman', true));


// =========================================
// phyz-prob: Uncertainty Cone
// =========================================
registerViz('ex-ucone', () => {
  const sim = WasmProbSim.uncertainty_cone();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-ucone');
  camera.position.set(2, 0, 12);
  controls.target.set(2, 0, 0);
  controls.enableRotate = false;

  // Origin marker
  scene.add(makeSphere(0.06, DARK));
  const dotPos = new Float32Array(N * 3);
  const dotCol = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(dotCol, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 5, vertexColors: true, sizeAttenuation: false })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(4);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
      const t = i / N;
      dotCol[i*3] = 0.29 + t * 0.6; dotCol[i*3+1] = 0.37 * (1-t); dotCol[i*3+2] = 0.84 * (1-t);
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    const el = document.getElementById('stat-ucone');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} trajectories  spread=${sim.spread().toFixed(2)}`;
  }};
});


// =========================================
// phyz-prob: SVGD Particles
// =========================================
registerViz('ex-svgd', () => {
  const sim = WasmProbSim.svgd_particles();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-svgd');
  camera.position.set(0, 0.2, 7);
  controls.target.set(0, 0.2, 0);
  controls.enableRotate = false;

  // Target distribution markers
  const t1 = makeSphere(0.08, 0x2e7d32, { transparent: true, opacity: 0.3 }); t1.position.set(-1, 0, 0); scene.add(t1);
  const t2 = makeSphere(0.08, 0x2e7d32, { transparent: true, opacity: 0.3 }); t2.position.set(1, 0.5, 0); scene.add(t2);

  const dotPos = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 4, color: ACCENT, sizeAttenuation: false })));

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(2);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
    }
    geo.attributes.position.needsUpdate = true;
    const el = document.getElementById('stat-svgd');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} particles  SVGD → GMM`;
    const _cur = sim.positions()[0];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-prob: Monte Carlo Bouncing Balls
// =========================================
registerViz('ex-mcballs', () => {
  const sim = WasmProbSim.monte_carlo();
  const N = sim.num_particles();
  const { scene, camera, controls, canvas } = createScene('ex-mcballs');
  camera.position.set(0, 1.5, 10);
  controls.target.set(0, 1, 0);
  controls.enableRotate = false;

  scene.add(makeGround(10, 1, 0));
  const dotPos = new Float32Array(N * 3);
  const dotCol = new Float32Array(N * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(dotPos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(dotCol, 3));
  scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 5, vertexColors: true, sizeAttenuation: false })));

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) {
      dotPos[i*3] = pos[i*2]; dotPos[i*3+1] = pos[i*2+1]; dotPos[i*3+2] = 0;
      const t = i / N;
      dotCol[i*3] = 0.9 * t; dotCol[i*3+1] = 0.3 + 0.4 * (1-t); dotCol[i*3+2] = 0.85 * (1-t);
    }
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    const el = document.getElementById('stat-mcballs');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} samples  spread=${sim.spread().toFixed(2)}`;
    const _cur = sim.positions()[1];
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-diff: Gradient Target
// =========================================
registerViz('ex-gradtarget', () => {
  const sim = WasmDiffGradientSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-gradtarget');
  camera.position.set(0.3, -0.3, 6);
  controls.target.set(0.3, -0.5, 0);

  scene.add(makeSphere(0.04, DARK));
  const rod = makeCyl(0.02, 1.5, MUTED); scene.add(rod);
  const bob = makeSphere(0.08, ACCENT); scene.add(bob);
  // Target marker
  const target = makeSphere(0.06, 0x2e7d32, { transparent: true, opacity: 0.5 });
  target.position.set(sim.target_x(), 0, 0);
  scene.add(target);
  // Loss curve as line
  const lossMax = 200;
  const lossGeo = new THREE.BufferGeometry();
  const lossPos = new Float32Array(lossMax * 3);
  lossGeo.setAttribute('position', new THREE.BufferAttribute(lossPos, 3));
  lossGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(lossGeo, new THREE.LineBasicMaterial({ color: 0xe74c3c })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(1);
    const x = sim.current_x(), y = sim.current_y();
    bob.position.set(x, y, 0);
    rod.position.set(x / 2, y / 2, 0);
    rod.rotation.z = Math.atan2(x, -y);
    const hist = sim.loss_history();
    const n = Math.min(hist.length, lossMax);
    const maxL = Math.max(...hist.slice(0, n), 0.1);
    for (let i = 0; i < n; i++) {
      lossPos[i*3] = 1.2 + i * (1.0/lossMax);
      lossPos[i*3+1] = -1.0 + (hist[i] / maxL) * 1.5;
      lossPos[i*3+2] = 0;
    }
    lossGeo.attributes.position.needsUpdate = true;
    lossGeo.setDrawRange(0, n);
    const el = document.getElementById('stat-gradtarget');
    if (el) el.textContent = `iter=${sim.iteration()}  loss=${sim.current_loss().toFixed(4)}  θ₀=${sim.theta0().toFixed(3)}`;
  }};
});


// =========================================
// phyz-diff: Jacobian Heatmap
// =========================================
registerViz('ex-jacheat', () => {
  const sim = WasmDiffJacobianSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-jacheat');
  camera.position.set(0, -0.3, 4.5);
  controls.target.set(0, -0.5, 0);

  scene.add(makeSphere(0.04, DARK));
  const rod = makeCyl(0.02, 1.5, MUTED); scene.add(rod);
  const bob = makeSphere(0.08, ACCENT); scene.add(bob);

  // 2x2 Jacobian cells
  const cellSize = 0.3;
  const cells = [];
  for (let r = 0; r < 2; r++) {
    for (let c = 0; c < 2; c++) {
      const geo = new THREE.BoxGeometry(cellSize, cellSize, 0.02);
      const mat = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(1.3 + c * (cellSize + 0.05), 0.2 - r * (cellSize + 0.05), 0);
      scene.add(mesh);
      cells.push(mesh);
    }
  }

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const x = sim.bob_x(), y = sim.bob_y();
    bob.position.set(x, y, 0);
    rod.position.set(x / 2, y / 2, 0);
    rod.rotation.z = Math.atan2(x, -y);
    const jac = sim.jacobian();
    for (let i = 0; i < 4; i++) {
      const v = Math.min(Math.abs(jac[i]) / 2.0, 1.0);
      const hue = jac[i] > 0 ? 0.6 : 0.0;
      cells[i].material.color.setHSL(hue, 0.7, 0.3 + v * 0.4);
    }
    const el = document.getElementById('stat-jacheat');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  J=[${jac.map(v=>v.toFixed(3)).join(',')}]`;
    const _cur = sim.angle();
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-diff: Sensitivity
// =========================================
registerViz('ex-sensitivity', () => {
  const sim = WasmDiffSensitivitySim.new();
  const { scene, camera, controls, canvas } = createScene('ex-sensitivity');
  camera.position.set(0, -0.3, 4.5);
  controls.target.set(0, -0.5, 0);

  // Two pendulums
  scene.add(makeSphere(0.04, DARK));
  const rodA = makeCyl(0.02, 1.5, MUTED); scene.add(rodA);
  const bobA = makeSphere(0.07, ACCENT); scene.add(bobA);
  const rodB = makeCyl(0.02, 1.5, 0xe74c3c); scene.add(rodB);
  const bobB = makeSphere(0.07, 0xe74c3c); scene.add(bobB);
  const trailA = makeTrail(300, ACCENT, 0.25); scene.add(trailA.line);
  const trailB = makeTrail(300, 0xe74c3c, 0.25); scene.add(trailB.line);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const pa = sim.pos_a(), pb = sim.pos_b();
    bobA.position.set(pa[0], pa[1], 0);
    rodA.position.set(pa[0]/2, pa[1]/2, 0);
    rodA.rotation.z = Math.atan2(pa[0], -pa[1]);
    bobB.position.set(pb[0], pb[1], 0);
    rodB.position.set(pb[0]/2, pb[1]/2, 0);
    rodB.rotation.z = Math.atan2(pb[0], -pb[1]);
    pushTrail(trailA, pa[0], pa[1], 0);
    pushTrail(trailB, pb[0], pb[1], 0);
    const div = sim.actual_divergence();
    const el = document.getElementById('stat-sensitivity');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  Δq=${div.length > 0 ? div[div.length-1].toFixed(5) : '?'}  analytical Jacobian`;
  }};
});


// =========================================
// phyz-mjcf: Ant Skeleton
// =========================================
registerViz('ex-ant', () => {
  const sim = WasmMjcfAntSim.new();
  const N = sim.nbodies();
  const { scene, camera, controls, canvas } = createScene('ex-ant');
  camera.position.set(0, -0.5, 6);
  controls.target.set(0, -0.5, 0);

  // Torso marker
  scene.add(makeSphere(0.08, ACCENT));
  const joints = [], rods = [];
  for (let i = 0; i < N; i++) {
    const isEnd = (i % 2 === 1);
    const j = makeSphere(0.04, isEnd ? 0xe74c3c : DARK);
    scene.add(j); joints.push(j);
    const rod = makeCyl(0.015, 0.5, MUTED);
    scene.add(rod); rods.push(rod);
  }

  const _yUp = new THREE.Vector3(0, 1, 0);
  const _dir = new THREE.Vector3();
  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const epos = sim.body_endpoint_positions();
    const jpos = sim.joint_positions();
    for (let i = 0; i < N; i++) {
      const ex = epos[i*3], ey = epos[i*3+1], ez = epos[i*3+2];
      joints[i].position.set(ex, ey, ez);
      // Parent is either world origin or previous joint
      let px = 0, py = 0, pz = 0;
      if (i % 2 === 1) { // shin: parent is hip endpoint
        px = epos[(i-1)*3]; py = epos[(i-1)*3+1]; pz = epos[(i-1)*3+2];
      } else { // hip: parent is joint origin (offset from torso)
        px = jpos[i*3]; py = jpos[i*3+1]; pz = jpos[i*3+2];
      }
      const dx = ex - px, dy = ey - py, dz = ez - pz;
      const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
      rods[i].position.set((px+ex)/2, (py+ey)/2, (pz+ez)/2);
      // 3D rod orientation: rotate cylinder from Y-up to direction vector
      _dir.set(dx, dy, dz).normalize();
      rods[i].quaternion.setFromUnitVectors(_yUp, _dir);
      rods[i].scale.y = len / 0.5;
    }
    const el = document.getElementById('stat-ant');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} bodies  MJCF ant`;
  }};
});


// =========================================
// phyz-collision: Ragdoll Tumble
// =========================================
registerViz('ex-ragdoll', () => {
  const sim = WasmRagdollSim.new();
  const N = sim.num_particles();
  const nCon = sim.num_constraints();
  const { scene, camera, controls, canvas } = createScene('ex-ragdoll');
  camera.position.set(0.5, 2.0, 6);
  controls.target.set(0.5, 1.5, 0);

  // Draw stairs
  const stairGeo = sim.stair_geometry();
  const nSteps = sim.num_steps();
  for (let s = 0; s < nSteps; s++) {
    const x0 = stairGeo[s*4], y0 = stairGeo[s*4+1];
    const x1 = stairGeo[s*4+2];
    const w = x1 - x0, h = 0.05;
    const step = new THREE.Mesh(
      new THREE.BoxGeometry(w, h, 0.6),
      new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 })
    );
    step.position.set((x0+x1)/2, y0 - h/2, 0);
    scene.add(step);
  }

  // Floor
  scene.add(makeGround(6, 2, 0));

  // Ragdoll joints as spheres
  const jointColors = [0xe74c3c, DARK, DARK, DARK, ACCENT, ACCENT, ACCENT, ACCENT, 0x2e7d32, 0x2e7d32, 0x2e7d32, 0x2e7d32];
  const jointSizes = [0.06, 0.03, 0.03, 0.03, 0.025, 0.025, 0.025, 0.025, 0.025, 0.03, 0.025, 0.03];
  const joints = [];
  for (let i = 0; i < N; i++) {
    const s = makeSphere(jointSizes[i], jointColors[i]);
    scene.add(s); joints.push(s);
  }

  // Constraint links as line segments
  const linkPos = new Float32Array(nCon * 6);
  const linkGeo = new THREE.BufferGeometry();
  linkGeo.setAttribute('position', new THREE.BufferAttribute(linkPos, 3));
  scene.add(new THREE.LineSegments(linkGeo, new THREE.LineBasicMaterial({ color: MUTED, linewidth: 2 })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(8);
    const pos = sim.positions();
    for (let i = 0; i < N; i++) {
      joints[i].position.set(pos[i*2], pos[i*2+1], 0);
    }
    const ep = sim.constraint_endpoints();
    for (let c = 0; c < nCon; c++) {
      linkPos[c*6]   = ep[c*4];   linkPos[c*6+1] = ep[c*4+1]; linkPos[c*6+2] = 0;
      linkPos[c*6+3] = ep[c*4+2]; linkPos[c*6+4] = ep[c*4+3]; linkPos[c*6+5] = 0;
    }
    linkGeo.attributes.position.needsUpdate = true;
    const el = document.getElementById('stat-ragdoll');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ${N} joints  ${nCon} constraints`;
  }};
});


// =========================================
// phyz-coupling: Rube Goldberg Machine
// =========================================
registerViz('ex-rube', () => {
  const sim = WasmRubeGoldbergSim.new();
  const nDom = sim.num_dominoes();
  const dh = sim.domino_height();
  const dw = sim.domino_width();
  const { scene, camera, controls, canvas } = createScene('ex-rube');
  camera.position.set(0, 0.6, 5);
  controls.target.set(0, 0.4, 0);

  // Ball 1
  const ball1 = makeSphere(0.05, 0xe74c3c); scene.add(ball1);
  // Ball 2
  const ball2 = makeSphere(0.05, ACCENT); scene.add(ball2);
  // Pendulum rod + bob
  const pendRod = makeCyl(0.01, 0.7, MUTED); scene.add(pendRod);
  const pendBob = makeSphere(0.06, 0x7c4dff); scene.add(pendBob);
  const pendAnchor = makeSphere(0.02, DARK); scene.add(pendAnchor);
  // Dominoes
  const dominos = [];
  for (let i = 0; i < nDom; i++) {
    const dom = new THREE.Mesh(
      new THREE.BoxGeometry(dw, dh, 0.08),
      new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.6 })
    );
    scene.add(dom); dominos.push(dom);
  }
  // Ramp (static)
  const rampGeo = new THREE.BufferGeometry();
  // Will set from state
  const rampLine = new THREE.Line(rampGeo, new THREE.LineBasicMaterial({ color: MUTED }));
  scene.add(rampLine);
  // Shelf
  const shelf = new THREE.Mesh(
    new THREE.BoxGeometry(0.6, 0.04, 0.3),
    new THREE.MeshStandardMaterial({ color: 0xcccccc })
  );
  shelf.position.set(1.2, 0.48, 0); scene.add(shelf);
  // Floor
  scene.add(makeGround(6, 2, 0));
  // Bucket
  const bucketL = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.2, 0.2), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
  const bucketR = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.2, 0.2), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
  const bucketB = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.03, 0.2), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
  scene.add(bucketL); scene.add(bucketR); scene.add(bucketB);

  // Set initial ramp geometry
  const initState = sim.state();
  const rampIdx = 8 + nDom * 3;
  const rampPts = [
    new THREE.Vector3(initState[rampIdx], initState[rampIdx+1], 0),
    new THREE.Vector3(initState[rampIdx+2], initState[rampIdx+3], 0)
  ];
  rampGeo.setFromPoints(rampPts);
  // Bucket position
  const bx = initState[rampIdx+4], by = initState[rampIdx+5], bw = initState[rampIdx+6];
  bucketL.position.set(bx - bw/2, by + 0.1, 0);
  bucketR.position.set(bx + bw/2, by + 0.1, 0);
  bucketB.position.set(bx, by, 0);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const s = sim.state();
    // Ball 1
    ball1.position.set(s[0], s[1], 0);
    // Ball 2
    ball2.position.set(s[2], s[3], 0);
    // Pendulum
    pendAnchor.position.set(s[4], s[5], 0);
    pendBob.position.set(s[6], s[7], 0);
    const pdx = s[6]-s[4], pdy = s[7]-s[5];
    pendRod.position.set((s[4]+s[6])/2, (s[5]+s[7])/2, 0);
    pendRod.rotation.z = Math.atan2(pdx, -pdy);
    pendRod.scale.y = Math.sqrt(pdx*pdx + pdy*pdy) / 0.7;
    // Dominoes
    for (let i = 0; i < nDom; i++) {
      const dx = s[8 + i*3];
      const dy = s[8 + i*3 + 1];
      const da = s[8 + i*3 + 2];
      // Domino pivots at base, rotates clockwise
      const cx = dx + (dh/2) * Math.sin(da);
      const cy = dy + (dh/2) * Math.cos(da);
      dominos[i].position.set(cx, cy, 0);
      dominos[i].rotation.z = -da;
    }
    const el = document.getElementById('stat-rube');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  ball→dominos→pendulum→bucket`;
  }};
});


// =========================================
// phyz-mjcf: Cartpole
// =========================================
registerViz('ex-cartpole', () => {
  const sim = WasmMjcfCartpoleSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-cartpole');
  camera.position.set(0, 0.5, 5);
  controls.target.set(0, 0.5, 0);

  // Ground rail
  scene.add(makeGround(4, 1, 0));
  // Cart
  const cart = new THREE.Mesh(
    new THREE.BoxGeometry(0.4, 0.2, 0.3),
    new THREE.MeshStandardMaterial({ color: ACCENT, roughness: 0.5 })
  );
  cart.position.y = 0.1;
  scene.add(cart);
  // Pole
  const pole = makeCyl(0.025, 1.0, 0xe74c3c);
  scene.add(pole);
  const tip = makeSphere(0.05, 0xe74c3c);
  scene.add(tip);

  let _prev = 0;
  return { scene, camera, controls, canvas, update() {
    sim.step_n(16);
    const cx = sim.cart_x();
    cart.position.x = cx;
    const tx = sim.pole_tip_x(), ty = sim.pole_tip_y();
    pole.position.set((cx + tx)/2, 0.1 + ty/2, 0);
    pole.rotation.z = sim.pole_angle();
    tip.position.set(tx, 0.1 + ty, 0);
    const el = document.getElementById('stat-cartpole');
    if (el) el.textContent = `t=${sim.time().toFixed(1)}s  x=${cx.toFixed(2)}  θ=${sim.pole_angle().toFixed(3)}  PD ctrl`;
    const _cur = cx;
    const _delta = Math.abs(_cur - _prev);
    _prev = _cur;
    return _delta;
  }};
});


// =========================================
// phyz-mjcf: Model Editor (static skeleton)
// =========================================
registerViz('ex-mjcfeditor', () => {
  const sim = WasmMjcfEditorSim.parse("hip 0.4\nshin 0.6\nhip 0.4\nshin 0.6\nhip 0.4\nshin 0.6");
  const N = sim.n_bodies();
  const { scene, camera, controls, canvas } = createScene('ex-mjcfeditor');
  camera.position.set(0, -1, 4);
  controls.target.set(0, -1.2, 0);

  const pos = sim.positions();
  const nodes = [];
  for (let i = 0; i < pos.length / 2; i++) {
    const s = makeSphere(0.05, i === 0 ? ACCENT : DARK);
    s.position.set(pos[i*2], pos[i*2+1], 0);
    scene.add(s); nodes.push(s);
  }
  // Draw edges
  for (let i = 1; i < pos.length / 2; i++) {
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(pos[(i-1)*2], pos[(i-1)*2+1], 0),
      new THREE.Vector3(pos[i*2], pos[i*2+1], 0)
    ]);
    scene.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: MUTED })));
  }

  const el = document.getElementById('stat-mjcfeditor');
  if (el) el.textContent = `${N} bodies  parsed from text  MJCF skeleton`;

  return { scene, camera, controls, canvas, update() {} };
});


// =========================================
// phyz-real2sim: Parameter Fitting
// =========================================
registerViz('ex-paramfit', () => {
  const sim = WasmReal2SimFitSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-paramfit');
  camera.position.set(0, 0, 5);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  // Loss curve
  const lossMax = 200;
  const lossGeo = new THREE.BufferGeometry();
  const lossPos = new Float32Array(lossMax * 3);
  lossGeo.setAttribute('position', new THREE.BufferAttribute(lossPos, 3));
  lossGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(lossGeo, new THREE.LineBasicMaterial({ color: 0xe74c3c })));

  // Axes
  const axMat = new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.3 });
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-2,0,0), new THREE.Vector3(2,0,0)]), axMat));
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-2,-1.5,0), new THREE.Vector3(-2,1.5,0)]), axMat));

  // Target params marker
  const target = makeSphere(0.06, 0x2e7d32); target.position.set(0, 1, 0); scene.add(target);
  const current = makeSphere(0.06, 0xe74c3c); scene.add(current);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(1);
    const hist = sim.loss_history();
    const n = Math.min(hist.length, lossMax);
    const maxL = Math.max(...hist.slice(0, n), 0.01);
    for (let i = 0; i < n; i++) {
      lossPos[i*3] = -2 + i * (4.0/lossMax);
      lossPos[i*3+1] = -1.5 + (hist[i] / maxL) * 3.0;
      lossPos[i*3+2] = 0;
    }
    lossGeo.attributes.position.needsUpdate = true;
    lossGeo.setDrawRange(0, n);
    // Show current vs true params
    const m = sim.est_mass(), l = sim.est_length();
    current.position.set((m - 1.0) * 1.5, (l - 1.0) * 1.5, 0);
    const el = document.getElementById('stat-paramfit');
    if (el) el.textContent = `iter=${sim.iteration()}  m=${m.toFixed(2)}  L=${l.toFixed(2)}  loss=${sim.current_loss().toFixed(4)}`;
  }};
});


// =========================================
// phyz-real2sim: Loss Landscape
// =========================================
registerViz('ex-lossland', () => {
  const sim = WasmReal2SimLandscapeSim.new();
  const N = sim.grid_size();
  const { scene, camera, controls, canvas } = createScene('ex-lossland');
  camera.position.set(0, 0, 2.2);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  // Heatmap texture
  const data = new Uint8Array(N * N * 4);
  const grid = sim.grid();
  const gmin = Math.min(...grid), gmax = Math.max(...grid);
  for (let i = 0; i < N * N; i++) {
    const t = (grid[i] - gmin) / (gmax - gmin + 1e-10);
    data[i*4] = Math.floor(240 * t + 30 * (1-t));
    data[i*4+1] = Math.floor(80 * t + 100 * (1-t));
    data[i*4+2] = Math.floor(60 * t + 200 * (1-t));
    data[i*4+3] = 255;
  }
  const texture = new THREE.DataTexture(data, N, N, THREE.RGBAFormat);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.needsUpdate = true;
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: texture })));

  // GD path overlay
  const pathMax = 200;
  const pathGeo = new THREE.BufferGeometry();
  const pathPos = new Float32Array(pathMax * 3);
  pathGeo.setAttribute('position', new THREE.BufferAttribute(pathPos, 3));
  pathGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(pathGeo, new THREE.LineBasicMaterial({ color: 0xffffff })));
  const pathDot = makeSphere(0.04, 0xffffff); scene.add(pathDot);

  return { scene, camera, controls, canvas, update() {
    sim.step_n(1);
    const pm = sim.path_m(), pl = sim.path_l();
    const n = Math.min(pm.length, pathMax);
    for (let i = 0; i < n; i++) {
      pathPos[i*3] = ((pm[i] - 0.3) / 2.7) * 2.0 - 1.0;
      pathPos[i*3+1] = ((pl[i] - 0.5) / 2.0) * 2.0 - 1.0;
      pathPos[i*3+2] = 0.01;
    }
    pathGeo.attributes.position.needsUpdate = true;
    pathGeo.setDrawRange(0, n);
    if (n > 0) {
      pathDot.position.set(pathPos[(n-1)*3], pathPos[(n-1)*3+1], 0.02);
    }
    const el = document.getElementById('stat-lossland');
    if (el) el.textContent = `iter=${pm.length}  m=${sim.est_mass().toFixed(2)}  L=${sim.est_length().toFixed(2)}  GD path`;
  }};
});


// =========================================
// phyz-real2sim: Adam vs GD
// =========================================
registerViz('ex-adamgd', () => {
  const sim = WasmReal2SimAdamVsGdSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-adamgd');
  camera.position.set(0, 0, 5);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const axMat = new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.3 });
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-2,-1.5,0), new THREE.Vector3(2,-1.5,0)]), axMat));
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-2,-1.5,0), new THREE.Vector3(-2,1.5,0)]), axMat));

  const curveMax = 200;
  // GD curve (red)
  const gdGeo = new THREE.BufferGeometry();
  const gdPos = new Float32Array(curveMax * 3);
  gdGeo.setAttribute('position', new THREE.BufferAttribute(gdPos, 3));
  gdGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(gdGeo, new THREE.LineBasicMaterial({ color: 0xe74c3c })));

  // Adam curve (green)
  const adamGeo = new THREE.BufferGeometry();
  const adamPos = new Float32Array(curveMax * 3);
  adamGeo.setAttribute('position', new THREE.BufferAttribute(adamPos, 3));
  adamGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(adamGeo, new THREE.LineBasicMaterial({ color: 0x2e7d32 })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(1);
    const gd = sim.gd_loss(), adam = sim.adam_loss();
    const n = Math.min(gd.length, curveMax);
    const allLoss = [...gd.slice(0, n), ...adam.slice(0, n)];
    const maxL = Math.max(...allLoss, 0.01);
    for (let i = 0; i < n; i++) {
      const x = -2 + i * (4.0/curveMax);
      gdPos[i*3] = x; gdPos[i*3+1] = -1.5 + (gd[i] / maxL) * 3.0; gdPos[i*3+2] = 0;
      adamPos[i*3] = x; adamPos[i*3+1] = -1.5 + (adam[i] / maxL) * 3.0; adamPos[i*3+2] = 0;
    }
    gdGeo.attributes.position.needsUpdate = true;
    gdGeo.setDrawRange(0, n);
    adamGeo.attributes.position.needsUpdate = true;
    adamGeo.setDrawRange(0, n);
    const el = document.getElementById('stat-adamgd');
    const gdL = gd.length > 0 ? gd[gd.length-1].toFixed(4) : '?';
    const adamL = adam.length > 0 ? adam[adam.length-1].toFixed(4) : '?';
    if (el) el.textContent = `iter=${sim.iteration()}  GD=${gdL}  Adam=${adamL}`;
  }};
});


// =========================================
// phyz-regge: Curvature Slice
// =========================================
registerViz('ex-curvslice', () => {
  const sim = WasmReggeCurvatureSim.new();
  const G = sim.grid_size();
  const { scene, camera, controls, canvas } = createScene('ex-curvslice');
  camera.position.set(0, 0, 2.2);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const data = new Uint8Array(G * G * 4);
  const texture = new THREE.DataTexture(data, G, G, THREE.RGBAFormat);
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: texture })));

  let mass = 1.0, charge = 0.3, frame = 0;

  return { scene, camera, controls, canvas, update() {
    frame++;
    // Slowly vary mass and charge
    mass = 1.0 + 0.5 * Math.sin(frame * 0.01);
    charge = 0.3 + 0.2 * Math.sin(frame * 0.007);
    const lengths = sim.compute(mass, charge);
    const n = Math.min(lengths.length, G * G);
    const lmin = Math.min(...lengths.slice(0, n));
    const lmax = Math.max(...lengths.slice(0, n));
    for (let i = 0; i < G * G; i++) {
      if (i < n) {
        const t = (lengths[i] - lmin) / (lmax - lmin + 1e-10);
        data[i*4] = Math.floor(45 + t * 195);
        data[i*4+1] = Math.floor(40 + t * 180);
        data[i*4+2] = Math.floor(80 * (1-t) + 90 * t);
      } else {
        data[i*4] = 240; data[i*4+1] = 238; data[i*4+2] = 235;
      }
      data[i*4+3] = 255;
    }
    texture.needsUpdate = true;
    const el = document.getElementById('stat-curvslice');
    if (el) el.textContent = `M=${mass.toFixed(2)}  Q=${charge.toFixed(2)}  ${n} edges  Reissner-Nordström`;
  }};
});


// =========================================
// phyz-regge: Symmetry Bars
// =========================================
registerViz('ex-symbars', () => {
  const sim = WasmReggeSymmetrySim.new();
  const vals = sim.compute(); // [flat_gauge, flat_trans, rn_gauge, rn_trans, kerr_gauge, kerr_trans]
  const { scene, camera, controls, canvas } = createScene('ex-symbars');
  camera.position.set(0, 0, 5);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const labels = ['flat\ngauge', 'flat\ntrans', 'RN\ngauge', 'RN\ntrans', 'Kerr\ngauge', 'Kerr\ntrans'];
  const colors = [ACCENT, ACCENT, 0xe74c3c, 0xe74c3c, 0x2e7d32, 0x2e7d32];
  const maxV = Math.max(...vals, 0.001);
  const bars = [];

  for (let i = 0; i < 6; i++) {
    const h = Math.max((vals[i] / maxV) * 2.0, 0.02);
    const bar = new THREE.Mesh(
      new THREE.BoxGeometry(0.25, h, 0.1),
      new THREE.MeshStandardMaterial({ color: colors[i] })
    );
    bar.position.set(-1.5 + i * 0.6, -1.0 + h/2, 0);
    scene.add(bar);
    bars.push(bar);
  }

  const el = document.getElementById('stat-symbars');
  if (el) el.textContent = `Noether currents: flat/RN/Kerr × gauge/translation`;

  return { scene, camera, controls, canvas, update() {} };
});


// =========================================
// phyz-regge: Action Landscape
// =========================================
registerViz('ex-actionland', () => {
  const sim = WasmReggeActionSim.new();
  const scales = sim.scales(), actions = sim.actions();
  const { scene, camera, controls, canvas } = createScene('ex-actionland');
  camera.position.set(0, 0, 5);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  // Axes
  const axMat = new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.3 });
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-2,-1.5,0), new THREE.Vector3(2,-1.5,0)]), axMat));
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-2,-1.5,0), new THREE.Vector3(-2,1.5,0)]), axMat));

  // Action curve
  const n = scales.length;
  const amin = Math.min(...actions), amax = Math.max(...actions);
  const curvePts = [];
  for (let i = 0; i < n; i++) {
    const x = -2 + (scales[i] - 0.3) / 2.7 * 4.0;
    const y = -1.5 + ((actions[i] - amin) / (amax - amin + 1e-10)) * 3.0;
    curvePts.push(new THREE.Vector3(x, y, 0));
  }
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(curvePts), new THREE.LineBasicMaterial({ color: ACCENT })));

  // GD dot
  const gdDot = makeSphere(0.06, 0xe74c3c); scene.add(gdDot);
  // GD path
  const pathMax = 200;
  const pathGeo = new THREE.BufferGeometry();
  const pathPos = new Float32Array(pathMax * 3);
  pathGeo.setAttribute('position', new THREE.BufferAttribute(pathPos, 3));
  pathGeo.setDrawRange(0, 0);
  scene.add(new THREE.Line(pathGeo, new THREE.LineBasicMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.5 })));

  return { scene, camera, controls, canvas, update() {
    sim.step_n(1);
    const path = sim.gd_path();
    const np = Math.min(path.length, pathMax);
    for (let i = 0; i < np; i++) {
      const s = path[i];
      const x = -2 + (s - 0.3) / 2.7 * 4.0;
      // Find corresponding action value
      const si = Math.floor((s - 0.3) / 2.7 * (n-1));
      const a = si >= 0 && si < n ? actions[si] : 0;
      const y = -1.5 + ((a - amin) / (amax - amin + 1e-10)) * 3.0;
      pathPos[i*3] = x; pathPos[i*3+1] = y; pathPos[i*3+2] = 0.01;
    }
    pathGeo.attributes.position.needsUpdate = true;
    pathGeo.setDrawRange(0, np);
    const cs = sim.current_scale();
    const cx = -2 + (cs - 0.3) / 2.7 * 4.0;
    const csi = Math.floor((cs - 0.3) / 2.7 * (n-1));
    const ca = csi >= 0 && csi < n ? actions[csi] : 0;
    const cy = -1.5 + ((ca - amin) / (amax - amin + 1e-10)) * 3.0;
    gdDot.position.set(cx, cy, 0.02);
    const el = document.getElementById('stat-actionland');
    if (el) el.textContent = `scale=${cs.toFixed(3)}  S=${sim.current_action().toFixed(2)}  Einstein-Maxwell`;
  }};
});


// =========================================
// phyz-compile: Kernel IR
// =========================================
registerViz('ex-kernelir', () => {
  const sim = WasmCompileIrSim.new();
  const names = sim.node_names();
  const depths = sim.node_depths();
  const parents = sim.node_parents();
  const N = sim.num_nodes();
  const { scene, camera, controls, canvas } = createScene('ex-kernelir');
  camera.position.set(0, -0.5, 6);
  controls.target.set(0, -0.5, 0);
  controls.enableRotate = false;

  const nodeColors = [ACCENT, 0x2e7d32, 0x2e7d32, 0x7c4dff, 0xe74c3c, 0xe74c3c, 0x2e7d32];
  const nodes = [];
  for (let i = 0; i < N; i++) {
    const d = depths[i];
    const x = (i - N/2) * 0.45;
    const y = -d * 0.6;
    const s = makeSphere(0.08, nodeColors[i] || DARK);
    s.position.set(x, y, 0);
    scene.add(s); nodes.push(s);

    // Edge to parent
    if (parents[i] >= 0) {
      const pi = parents[i];
      const px = (pi - N/2) * 0.45, py = -depths[pi] * 0.6;
      const geo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(px, py, 0), new THREE.Vector3(x, y, 0)
      ]);
      scene.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: MUTED, transparent: true, opacity: 0.5 })));
    }
  }

  const el = document.getElementById('stat-kernelir');
  if (el) el.textContent = `${N} nodes  heat_step kernel  IR DAG`;

  return { scene, camera, controls, canvas, update() {} };
});


// =========================================
// phyz-compile: WGSL Output
// =========================================
registerViz('ex-wgslout', () => {
  const sim = WasmCompileWgslSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-wgslout');
  camera.position.set(0, 0, 2.2);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  // Render WGSL as text on a DataTexture
  const texW = 256, texH = 256;
  const data = new Uint8Array(texW * texH * 4);
  const texture = new THREE.DataTexture(data, texW, texH, THREE.RGBAFormat);
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: texture })));

  let frame = 0;

  return { scene, camera, controls, canvas, update() {
    frame++;
    if (frame % 180 === 0) sim.next(); // cycle every 3 seconds

    // Draw a code-like pattern (colored bars representing WGSL lines)
    const nLines = sim.source_lines();
    const lineH = Math.floor(texH / Math.max(nLines + 2, 1));
    for (let y = 0; y < texH; y++) {
      for (let x = 0; x < texW; x++) {
        const i = (y * texW + x) * 4;
        const lineIdx = Math.floor(y / lineH);
        if (lineIdx < nLines) {
          // Simulated code coloring
          const indent = (lineIdx === 0 || lineIdx === nLines - 1) ? 0 : 20;
          if (x < indent) {
            data[i] = 250; data[i+1] = 249; data[i+2] = 247;
          } else {
            const barW = 120 + (lineIdx * 37 % 100);
            if (x < indent + barW) {
              const h = (lineIdx * 0.17) % 1.0;
              const c = new THREE.Color().setHSL(h, 0.3, 0.55);
              data[i] = Math.floor(c.r * 255);
              data[i+1] = Math.floor(c.g * 255);
              data[i+2] = Math.floor(c.b * 255);
            } else {
              data[i] = 240; data[i+1] = 239; data[i+2] = 237;
            }
          }
        } else {
          data[i] = 240; data[i+1] = 239; data[i+2] = 237;
        }
        data[i+3] = 255;
      }
    }
    texture.needsUpdate = true;
    const el = document.getElementById('stat-wgslout');
    if (el) el.textContent = `${sim.current_label()}  ${nLines} lines  WGSL @compute`;
  }};
});


// =========================================
// phyz-compile: Fusion Viz
// =========================================
registerViz('ex-fusionviz', () => {
  const sim = WasmCompileFusionSim.new();
  const { scene, camera, controls, canvas } = createScene('ex-fusionviz');
  camera.position.set(0, 0, 5);
  controls.target.set(0, 0, 0);
  controls.enableRotate = false;

  const aNames = sim.a_names(), bNames = sim.b_names(), fusedNames = sim.fused_names();
  const aN = sim.a_count(), bN = sim.b_count(), fN = sim.fused_count();

  // Create nodes for kernel A (left)
  const aNodes = [];
  for (let i = 0; i < aN; i++) {
    const s = makeSphere(0.08, ACCENT);
    scene.add(s); aNodes.push(s);
  }
  // Create nodes for kernel B (right)
  const bNodes = [];
  for (let i = 0; i < bN; i++) {
    const s = makeSphere(0.08, 0xe74c3c);
    scene.add(s); bNodes.push(s);
  }
  // Edges within each kernel
  const aEdges = [], bEdges = [];
  for (let i = 1; i < aN; i++) {
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: ACCENT, transparent: true, opacity: 0.4 }));
    scene.add(line); aEdges.push(line);
  }
  for (let i = 1; i < bN; i++) {
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.4 }));
    scene.add(line); bEdges.push(line);
  }

  return { scene, camera, controls, canvas, update() {
    sim.step_n(1);
    const p = sim.progress();
    // Kernel A: starts left, moves center-left
    for (let i = 0; i < aN; i++) {
      const x0 = -1.5, x1 = -0.5;
      const x = x0 + (x1 - x0) * p;
      const y = 1.0 - i * 0.6;
      aNodes[i].position.set(x, y, 0);
      // Fade out store node (last one) during fusion
      if (i === aN - 1) {
        aNodes[i].material.opacity = 1.0 - p;
        aNodes[i].material.transparent = true;
      }
    }
    // Kernel B: starts right, moves center-right
    for (let i = 0; i < bN; i++) {
      const x0 = 1.5, x1 = 0.5;
      const x = x0 + (x1 - x0) * p;
      const y = 1.0 - i * 0.6;
      bNodes[i].position.set(x, y, 0);
      if (i === 0) {
        bNodes[i].material.opacity = 1.0 - p;
        bNodes[i].material.transparent = true;
      }
    }
    // Update edges
    for (let i = 0; i < aEdges.length; i++) {
      const arr = aEdges[i].geometry.attributes.position.array;
      arr[0] = aNodes[i].position.x; arr[1] = aNodes[i].position.y; arr[2] = 0;
      arr[3] = aNodes[i+1].position.x; arr[4] = aNodes[i+1].position.y; arr[5] = 0;
      aEdges[i].geometry.attributes.position.needsUpdate = true;
    }
    for (let i = 0; i < bEdges.length; i++) {
      const arr = bEdges[i].geometry.attributes.position.array;
      arr[0] = bNodes[i].position.x; arr[1] = bNodes[i].position.y; arr[2] = 0;
      arr[3] = bNodes[i+1].position.x; arr[4] = bNodes[i+1].position.y; arr[5] = 0;
      bEdges[i].geometry.attributes.position.needsUpdate = true;
    }
    const el = document.getElementById('stat-fusionviz');
    if (el) el.textContent = p < 0.5 ? `${aN}+${bN} ops  separate kernels` : p < 1.0 ? `fusing...  eliminating store/load` : `${fN} ops  fused kernel  -2 ops`;
  }};
});


// Start observing all registered canvases
for (const canvasId of vizEntries.keys()) {
  const canvas = document.getElementById(canvasId);
  if (canvas) vizObserver.observe(canvas);
}
</script>

</body>
</html>
